{"version":3,"sources":["vs/platform/files/node/watcher/unix/fake","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/errors.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/arrays.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/functional.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/iterator.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/linkedList.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/event.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/cancellation.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/async.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/platform.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/process.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/path.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/stream.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/strings.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/buffer.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/types.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/extpath.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/objects.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/uri.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/console.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/marshalling.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/network.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/map.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/glob.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/normalization.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/common/uuid.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/node/decoder.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/node/pfs.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/node/extpath.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/node/processes.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiation.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/platform/files/common/files.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/platform/files/node/watcher/watcher.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/platform/files/node/watcher/unix/chokidarWatcherService.ts","vs/platform/files/node/watcher/unix/file:/github/workspace/lib/vscode/src/vs/platform/files/node/watcher/unix/watcherApp.ts"],"names":["__m","__M","deps","result","i","len","length","ErrorHandler","[object Object]","this","listeners","unexpectedErrorHandler","e","setTimeout","stack","Error","message","listener","push","_removeListener","forEach","splice","indexOf","newUnexpectedErrorHandler","emit","exports","errorHandler","setUnexpectedErrorHandler","onUnexpectedError","isPromiseCanceledError","onUnexpectedExternalError","transformErrorForSerialization","error","name","$isError","stacktrace","canceledName","canceled","illegalArgument","illegalState","readonly","disposed","what","getErrorMessage","err","split","String","NotImplementedError","super","NotSupportedError","findFirstInSorted","array","p","low","high","mid","Math","floor","mergeSort","data","compare","_sort","a","lo","hi","aux","leftIdx","rightIdx","_merge","sortedDiff","before","after","pushSplice","start","deleteCount","toInsert","latest","beforeIdx","afterIdx","slice","beforeElement","afterElement","n","topStep","m","element","pop","j","remove","index","tail","tail2","arr","equals","one","other","itemEquals","b","binarySearch","key","comparator","comp","quickSelect","nth","TypeError","pivotValue","random","lower","higher","pivots","value","val","groupBy","currentGroup","undefined","delta","splices","removed","added","top","sort","topAsync","batch","token","Promise","resolve","reject","o","min","isCancellationRequested","errors_1","then","coalesce","filter","coalesceInPlace","to","move","from","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","position","seen","Object","create","elem","distinctES6","Set","has","add","uniqueFilter","lastIndex","fn","firstOrDefault","notFoundValue","commonPrefixLength","flatten","concat","range","arg","indexer","mapper","reduce","r","t","insert","arrayInsert","target","insertIndex","insertArr","shuffle","_seed","rand","seed","x","sin","temp","pushToStart","unshift","pushToEnd","mapArrayOrNot","items","map","asArray","getRandomElement","once","_this","didCall","apply","arguments","Iterable","is","thing","Symbol","iterator","_empty","freeze","empty","single","iterable","first","next","some","predicate","iterables","consume","atMost","Number","POSITIVE_INFINITY","consumed","done","TRACK_DISPOSABLES","__is_disposable_tracked__","markTracked","Disposable","None","_a","trackDisposable","console","log","MultiDisposeError","errors","join","dispose","iterator_1","d","isDisposable","combinedDisposable","disposables","toDisposable","self","DisposableStore","_toDispose","_isDisposed","clear","values","DISABLE_DISPOSED_WARNING","warn","_store","MutableDisposable","_value","ReferenceCollection","references","Map","args","reference","get","counter","object","createReferencedObject","set","functional_1","destroyReferencedObject","delete","ImmortalReference","Node","Undefined","prev","LinkedList","_first","_last","_size","size","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","res","node","anchor","Event","event","thisArgs","didFire","call","snapshot","each","merge","initial","output","emitter","Emitter","fire","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","_output","latch","cache","firstCall","shouldEmit","lifecycle_1","signal","any","events","stopwatch","Date","getTime","_","buffer","nextTick","_buffer","flush","ChainableEvent","chain","fromNodeEventEmitter","eventName","id","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","toPromise","c","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","oldValue","LeakageMonitor","customThreshold","toString","_warnCountdown","_stacks","listenerCount","threshold","count","topStack","topCount","options","_disposed","_options","_leakageMon","_event","_listeners","linkedList_1","firstListener","isEmpty","removeMonitor","onFirstListenerDidAdd","onListenerDidAdd","check","_noop","_deliveryQueue","shift","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","toArray","AsyncEmitter","promiseJoin","_asyncDeliveryQueue","thenables","assign","waitUntil","isFrozen","all","catch","EventMultiplexer","hasListeners","hook","unhook","idx","EventBufferer","buffers","Relay","listening","inputEvent","inputEventListener","input","shortcutEvent","callback","context","bind","CancellationToken","isCancellationToken","Cancelled","MutableToken","onCancellationRequested","event_1","_isCancelled","_emitter","CancellationTokenSource","parent","_token","_parentListener","cancel","isThenable","createCancelablePromise","source","cancellation_1","thenable","onfinally","finally","raceCancellation","defaultValue","race","raceCancellablePromises","async","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","raceTimeout","timeout","onTimeout","promiseResolve","timer","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","Sequencer","current","promiseTask","SequencerByKey","promiseMap","newPromise","Delayer","defaultDelay","completionPromise","doResolve","doReject","task","cancelTimeout","ThrottledDelayer","delayer","throttler","trigger","isTriggered","millis","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","ignoreErrors","sequence","promiseFactories","results","thenHandler","shouldStop","loop","factory","Limiter","maxDegreeOfParalellism","outstandingPromises","runningPromises","_onFinished","onFinished","iLimitedTask","Queue","ResourceQueue","queues","resource","TimeoutTimer","runner","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","isScheduled","doRun","RunOnceWorker","units","unit","schedule","requestIdleCallback","cancelIdleCallback","dummyIdle","didTimeout","timeRemaining","runWhenIdle","IdleValue","executor","_didRun","_executor","_error","_handle","retry","retries","lastError","TaskSequentializer","taskId","_pending","pending","onCancel","donePending","triggerNext","_next","run","promiseReject","IntervalCounter","lastIncrementTime","now","_isWindows","_isMacintosh","_isLinux","_isNative","_isWeb","_isIOS","_locale","_language","_translationsConfigFile","_userAgent","_globals","global","nodeProcess","process","vscode","isElectronRenderer","versions","electron","type","navigator","platform","rawNlsConfig","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","userAgent","maxTouchPoints","language","el","document","getElementById","getAttribute","Platform","PlatformToString","_platform","isWindows","isMacintosh","isLinux","isNative","isWeb","isIOS","isRootUser","getuid","Language","isDefaultVariant","isDefault","translationsConfigFile","globals","setImmediate","postMessage","importScripts","vscodeSetImmediateId","candidate","lastId","myId","OperatingSystem","OS","_isLittleEndian","_isLittleEndianComputed","isLittleEndian","test","Uint8Array","view","Uint16Array","safeProcess","platform_1","cwd","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","ErrorInvalidArgType","expected","actual","determiner","replace","msg","code","validateString","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","_format","sep","pathObject","dir","root","base","ext","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","last","firstPart","paths","joined","needsReplace","slashCount","firstLen","normalize","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","offset","end","matchedSlash","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","format","ret","delimiter","posix","trailingSeparator","toNamespacedPath","hasRoot","relative","dirname","basename","extname","isReadableStream","pause","resume","destroy","every","newWriteableStream","reducer","WriteableStreamImpl","isReadableBufferedStream","stream","ended","state","flowing","destroyed","pendingWritePromises","flowData","flowErrors","flowEnd","highWaterMark","write","fullDataBuffer","pendingWritePromise","consumeReadable","readable","chunks","chunk","read","peekReadable","maxChunks","lastReadChunk","consumeStream","peekStream","streamListeners","dataListener","errorListener","endListener","toStream","toReadable","transform","transformer","isFalsyOrWhitespace","str","trim","_formatRegexp","escapeRegExpCharacters","ltrim","haystack","needle","needleLen","substring","rtrim","haystackLen","compareSubstring","aStart","aEnd","bStart","bEnd","codeA","codeB","aLen","bLen","compareSubstringIgnoreCase","diff","isUpperAsciiLetter","isLowerAsciiLetter","isAsciiLetter","doEqualsIgnoreCase","stopAt","abs","fromCharCode","isHighSurrogate","charCode","isLowSurrogate","computeCodePoint","highSurrogate","lowSurrogate","getNextCodePoint","nextCharCode","getPrevCodePoint","prevCharCode","_getCharContainingOffset","graphemeBreakTree","GraphemeBreakTree","getInstance","initialOffset","initialCodePoint","initialGraphemeBreakType","getGraphemeBreakType","graphemeBreakType","nextCodePoint","nextGraphemeBreakType","breakBetweenGraphemeBreakType","endOffset","prevCodePoint","prevGraphemeBreakType","match","group","parseInt","isNaN","escape","html","character","ch","convertSimple2RegExpPattern","pattern","stripWildcards","createRegExp","searchString","isRegex","wholeWord","charAt","modifiers","matchCase","multiline","unicode","RegExp","regExpLeadsToEndlessLoop","regexp","exec","regExpContainsBackreference","regexpValue","regExpFlags","ignoreCase","firstNonWhitespaceIndex","chCode","getLeadingWhitespace","lastNonWhitespaceIndex","startIndex","compareIgnoreCase","equalsIgnoreCase","startsWithIgnoreCase","candidateLength","commonSuffixLength","aLastIndex","bLastIndex","nextCharLength","prevCharLength","getCharContainingOffset","encodeUTF8","strLen","neededSize","strOffset","codePoint","arrOffset","decodeUTF8","byteLength","v0","uPrime","w1","w2","CONTAINS_RTL","containsRTL","CONTAINS_EMOJI","containsEmoji","IS_BASIC_ASCII","isFullWidthCharacter","isBasicASCII","UNUSUAL_LINE_TERMINATORS","containsUnusualLineTerminators","containsFullWidthCharacter","isEmojiImprecise","lcut","text","re","EL","COLOR_START","COLOR_END","startsWithUTF8BOM","breakTypeA","breakTypeB","removeAnsiEscapeCodes","UTF8_BOM_CHARACTER","stripUTF8BOM","substr","fuzzyContains","query","queryLen","targetLower","containsUppercaseCharacter","ignoreEscapedChars","uppercaseFirstLetter","toUpperCase","getNLines","singleLetterHash","GraphemeBreakType","_data","_INSTANCE","nodeCount","nodeIndex","hasBuffer","Buffer","hasTextEncoder","TextEncoder","hasTextDecoder","TextDecoder","textEncoder","textDecoder","VSBuffer","allocUnsafe","isBuffer","byteOffset","encode","strings","totalLength","alloc","decode","subarray","readUInt32BE","writeUInt32BE","readUInt32LE","writeUInt32LE","readUInt8","writeUInt8","destination","streamToBuffer","streams","readUInt16LE","writeUInt16LE","readableToBuffer","bufferToReadable","bufferedStreamToBuffer","bufferedStream","bufferToStream","streamToBufferReadableStream","fromString","wrap","newWriteableBufferStream","isString","isObject","isUndefined","isUndefinedOrNull","isStringArray","isNumber","isBoolean","isDefined","assertType","condition","assertIsDefined","assertAllDefined","hasOwnProperty","prototype","isFunction","validateConstraint","constraint","constructor","getAllPropertyNames","proto","getPrototypeOf","getOwnPropertyNames","isEmptyObject","areFunctions","objects","validateConstraints","constraints","getAllMethodNames","methods","prop","createProxyObject","methodNames","invoke","createProxyMethod","method","methodName","withNullAsUndefined","withUndefinedAsNull","NotImplementedProxy","Proxy","toSlashes","osPath","path_1","getRoot","firstLetter","pos","isWindowsDriveLetter","isUNC","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","char0","isValidBasename","isWindowsOS","invalidFileChars","isEqual","pathA","pathB","identityEquals","strings_1","isEqualOrParent","parentCandidate","sepOffset","sanitizeFilePath","endsWith","isRootOrDriveLetter","pathNormalized","indexOfPath","parseLineAndColumnAware","rawPath","segments","line","column","segment","segmentAsNumber","types_1","deepClone","keys","deepFreeze","_hasOwnProperty","oneKeys","otherKeys","cloneAndChange","changer","_cloneAndChange","changed","r1","r2","i2","mixin","overwrite","safeStringify","stringify","getOrDefault","k","baseValue","targetValue","getCaseInsensitive","lowercaseKey","equivalentKey","find","_schemePattern","_singleSlashStart","_doubleSlashStart","_slash","_regexp","URI","schemeOrData","authority","fragment","_strict","scheme","_schemeFix","_referenceResolution","_validateUri","fsPath","with","uriToFsPath","change","Uri","percentDecode","components","uri","pathFragment","newPath","file","skipEncoding","_asFormatted","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","58","47","63","35","91","93","64","33","36","38","39","40","41","42","43","44","59","61","32","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","encodeURIComponent","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","encoder","userinfo","_rEncodedAsHex","decodeURIComponentGraceful","decodeURIComponent","entry","parsedArguments","stackArgument","__$stack","findFirstFrame","newlineIndex","color","isRemoteConsoleLog","severity","getFirstFrame","arg0","topFrame","matches","uri_1","label","isOneStringArg","consoleArgs","replacer","flags","revive","depth","buffer_1","Schemas","inMemory","internal","walkThrough","walkThroughSnippet","http","https","mailto","untitled","command","vscodeRemote","vscodeRemoteResource","userData","vscodeCustomEditor","vscodeNotebook","vscodeNotebookCell","vscodeSettings","webviewPanel","vscodeWebview","vscodeWebviewResource","extension","RemoteAuthorities","_hosts","_ports","_connectionTokens","_preferredWebSchema","_delegate","schema","delegate","host","port","connectionToken","window","location","pathname","FileAccess","uriOrModule","moduleIdToUrl","toUri","rewrite","isUri","toUrl","getOrSet","mapToString","entries","setToString","StringIterator","_pos","PathIterator","_splitOnBackslash","_caseSensitive","_from","_to","justSeps","UriIteratorState","UriIterator","_ignorePathCasing","_states","_stateIdx","_pathIterator","network_1","reset","hasNext","cmp","TernarySearchTreeNode","left","right","TernarySearchTree","_iter","ignorePathCasing","_root","iter","oldElement","_delete","superStr","_values","_entries","ResourceMap","mapOrKeyFn","toKey","toStringTag","defaultToKey","clb","thisArg","tuple","Touch","LinkedMap","_map","_head","_tail","_state","touch","previous","addItemLast","addItemFirst","removeItem","callbackfn","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","max","checkTrim","trimOld","round","getEmptyExpression","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","splitChar","inBraces","inBrackets","curVal","char","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","patternKey","trimForExclusions","parsedPattern","wrapRelativePattern","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","withBasenames","allPaths","trivia3","trivia4and5","regExp","parseRegExp","regEx","s","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","toRegExp","arg2","extpath","matchPathEnds","nativePath","nativePathEnd","isRelativePattern","resultPattern","expression","when","hasSibling","matched","async_1","requiresSiblings","parseExpressionPattern","resultExpression","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","getBasenameTerms","patternOrExpression","getPathTerms","canNormalize","nfcCache","normalizeNFC","nfdCache","normalizeNFD","nonAsciiCharactersPattern","form","normalizedCache","cached","removeAccents","regex","_UUIDPattern","isUUID","_hex","padStart","_fillRandomValues","bucket","generateUuid","LineDecoder","encoding","stringDecoder","sd","StringDecoder","remaining","lastChar","RimRafMode","rimraf","mode","UNLINK","extpath_1","rimrafUnlink","pathInTemp","os","tmpdir","uuid_1","rename","rimrafMove","stat","lstat","isDirectory","isSymbolicLink","chmod","unlink","children","readdir","child","util_1","promisify","fs","rmdir","handleDirectoryChildren","readdirSync","normalization_1","oldPath","mkdirp","mkdir","recursive","MAX_FILE_SIZE","arch","MAX_HEAP_SIZE","rimrafSync","lstatSync","chmodSync","unlinkSync","rmdirSync","readdirWithFileTypes","withFileTypes","exists","statLink","lstats","symbolicLink","dangling","renameIgnoreError","symlink","truncate","readFile","writeFilePathQueues","writeFile","queueKey","existingWriteFileQueue","writeFileQueue","onFinish","ensureWriteFileQueue","toQueueKey","ensuredOptions","ensureWriteOptions","canFlush","flag","open","openError","fd","writeError","close","fdatasync","syncError","closeError","doWriteFileAndFlush","dirExists","copy","copiedSourcesIn","copiedSources","fileStat","reader","createReadStream","writer","createWriteStream","finished","finish","pipe","doCopyFile","files","writeFileSync","openSync","fdatasyncSync","closeSync","readDirsInDir","dirPath","directories","fileExists","isFile","whenDeleted","running","updateMtime","futimes","atime","MOVE","normalizePath","realcaseSync","found","pfs_1","prefix","ix","realpath","normalizedPath","access","constants","R_OK","realpathSync","accessSync","State","DataType","requestTypeToStr","responseTypeToStr","RequestType","ResponseType","BufferReader","bytes","BufferWriter","createSizeBuffer","readSizeBuffer","createOneByteBuffer","BufferPresets","serialize","deserialize","ChannelServer","protocol","ctx","logger","timeoutDelay","channels","activeRequests","pendingRequests","protocolListener","onMessage","onRawMessage","sendResponse","channelName","channel","flushPendingRequests","response","msgLength","send","logOutgoing","header","body","sendBuffer","logIncoming","onPromise","onEventListen","disposeActiveRequest","request","collectPendingRequest","cancellationTokenSource","disposable","listen","timeoutTimer","requests","RequestInitiator","ChannelClient","Uninitialized","handlers","lastRequestId","_onDidInitialize","onDidInitialize","onBuffer","that","cancellationToken","requestPromise","requestEvent","doRequest","sendRequest","uninitializedPromise","Idle","whenInitialized","cancellationTokenListener","onResponse","IPCServer","onDidClientConnect","_connections","_onDidAddConnection","onDidAddConnection","_onDidRemoveConnection","onDidRemoveConnection","onDidClientDisconnect","onFirstMessage","channelServer","channelClient","registerChannel","connection","connections","routerOrClientFilter","connectionPromise","arrays_1","routeCall","getDelayedChannel","getChannel","getMulticastEvent","routeEvent","clientFilter","eventMultiplexer","relay","IPCClient","ipcLogger","getNextTickChannel","didTick","propertyIsEvent","StaticRouter","hub","route","createChannelReceiver","service","disableMarshalling","mapEventNameToEvent","eventImpl","marshalling_1","createChannelSender","_target","propKey","properties","methodArgs","colorTables","prettyWithoutArrays","logWithColors","direction","req","initiator","pretty","colorTable","IPCLogger","_outgoingPrefix","_incomingPrefix","_totalIncoming","_totalOutgoing","requestId","define","nls","getWindowsCode","status","getWindowsShell","environment","AbstractProcess","arg3","arg4","cmd","shell","executable","isShellCommand","childProcess","childProcessPromise","terminateRequested","newEnv","WellKnowCommands","pp","localize","useExec","cc","ee","cp","stdout","stderr","killed","handleExec","closeHandler","handleClose","terminated","Types","cmdCode","Objects","windowsVerbatimArguments","detached","quotedCommand","quotedArg","commandLine","quoted","ensureQuotes","spawn","pidResolve","pid","handleSpawn","stdio","killProcess","execFile","success","asFileUri","require","kill","terminateProcess","cmdShell","ant","cmake","eslint","gradle","grunt","gulp","jake","jenkins","jshint","make","maven","msbuild","msc","nmake","npm","rake","tsc","xbuild","LineProcess","stdoutLineDecoder","stderrLineDecoder","lineDecoder","decoder_1","sync","stdoutLine","stderrLine","createQueuedSender","msgQueue","useQueue","msgQueueCopy","findExecutable","PATH","pathEntry","fullPath","withExtension","Server","ipc_1","Client","modulePath","_onDidProcessExit","onDidProcessExit","disposeDelayer","_client","getCachedChannel","disposeClient","client","forkOpts","objects_1","VSCODE_PARENT_PID","freshExecArgv","execArgv","debug","debugBrk","child_process_1","fork","onMessageEmitter","console_1","serverName","sender","processes_1","connected","onExit","_util","storeServiceDependency","optional","DI_TARGET","DI_DEPENDENCIES","createDecorator","serviceId","serviceIds","getServiceDependencies","ctor","IInstantiationService","serviceIdentifier","FileSystemProviderErrorCode","IFileService","instantiation_1","FileType","FileSystemProviderCapabilities","hasReadWriteCapability","provider","capabilities","hasFileFolderCopyCapability","hasOpenReadWriteCloseCapability","hasFileReadStreamCapability","FileSystemProviderError","createFileSystemProviderError","providerError","markAsFileSystemProviderError","toFileSystemProviderErrorCode","Unknown","FileExists","FileIsADirectory","FileNotADirectory","FileNotFound","FileExceedsMemoryLimit","FileTooLarge","NoPermissions","Unavailable","ensureFileSystemProviderError","nls_1","toFileOperationResult","FileOperationError","fileOperationResult","FileOperation","FileOperationEvent","operation","FileChangeType","FileChangesEvent","changes","updated","deleted","forUris","types","doContains","includeChildren","hasTypesFilter","includes","_b","findSuperstr","_c","_d","_e","findSubstr","_f","getOfType","eventsForType","filterFn","isParent","FileOperationResult","AutoSaveConfiguration","OFF","AFTER_DELAY","ON_FOCUS_CHANGE","ON_WINDOW_CHANGE","HotExitConfiguration","ON_EXIT","ON_EXIT_AND_WINDOW_CLOSE","FILES_ASSOCIATIONS_CONFIG","FILES_EXCLUDE_CONFIG","FileKind","ETAG_DISABLED","etag","mtime","whenProviderRegistered","fileService","canHandleResource","onDidChangeFileSystemProviderRegistrations","MIN_MAX_MEMORY_SIZE_MB","FALLBACK_MAX_MEMORY_SIZE_MB","BinarySize","KB","toFixed","MB","GB","TB","toFileChanges","normalizeFileChanges","normalizer","EventNormalizer","processEvent","normalized","mapPathToChange","existingEvent","currentChangeType","newChangeType","addedChangeEvents","deletedPaths","e1","e2","files_1","gracefulFs","gracefulify","noAsar","ChokidarWatcherService","_onDidChangeFile","_register","onDidChangeFile","_onDidLogMessage","onDidLogMessage","watchers","_watcherCount","wacherCount","pollingInterval","usePolling","verboseLogging","enabled","newRequests","requestsByBasePath","normalizeRoots","basePath","watcher","isEqualIgnore","excludes","stop","watch","watcherOpts","ignoreInitial","ignorePermissionErrors","followSymlinks","binaryInterval","disableGlobbing","isSingleFolder","ignored","realBasePath","realBasePathLength","realBasePathDiffers","chokidarWatcher","chokidar","useFsEvents","undeliveredFileEvents","fileEventDelayer","FS_EVENT_DELAY","eventType","glob","relPath","isIgnored","spamWarningLogged","spamCheckStartTime","EVENT_SPAM_WARNING_THRESHOLD","watcher_1","enospcErrorLogged","localeCompare","prevRequest","i1","server","ipc_cp_1","chokidarWatcherService_1"],"mappings":"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","file":"watcherApp.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\tlet low = 0,\n\t\thigh = array.length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = comparator(array[mid], key);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tlet pivotValue = data[Math.floor(data.length * Math.random())];\n\tlet lower: T[] = [];\n\tlet higher: T[] = [];\n\tlet pivots: T[] = [];\n\n\tfor (let value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\n/**\n * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`\n * so only use this when actually needing stable sort.\n */\nexport function mergeSort<T>(data: T[], compare: Compare<T>): T[] {\n\t_sort(data, compare, 0, data.length - 1, []);\n\treturn data;\n}\n\nfunction _merge<T>(a: T[], compare: Compare<T>, lo: number, mid: number, hi: number, aux: T[]): void {\n\tlet leftIdx = lo, rightIdx = mid + 1;\n\tfor (let i = lo; i <= hi; i++) {\n\t\taux[i] = a[i];\n\t}\n\tfor (let i = lo; i <= hi; i++) {\n\t\tif (leftIdx > mid) {\n\t\t\t// left side consumed\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else if (rightIdx > hi) {\n\t\t\t// right side consumed\n\t\t\ta[i] = aux[leftIdx++];\n\t\t} else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {\n\t\t\t// right element is less -> comes first\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else {\n\t\t\t// left element comes first (less or equal)\n\t\t\ta[i] = aux[leftIdx++];\n\t\t}\n\t}\n}\n\nfunction _sort<T>(a: T[], compare: Compare<T>, lo: number, hi: number, aux: T[]) {\n\tif (hi <= lo) {\n\t\treturn;\n\t}\n\tconst mid = lo + ((hi - lo) / 2) | 0;\n\t_sort(a, compare, lo, mid, aux);\n\t_sort(a, compare, mid + 1, hi, aux);\n\tif (compare(a[mid], a[mid + 1]) <= 0) {\n\t\t// left and right are sorted and if the last-left element is less\n\t\t// or equals than the first-right element there is nothing else\n\t\t// to do\n\t\treturn;\n\t}\n\t_merge(a, compare, lo, mid, hi, aux);\n}\n\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of mergeSort(data.slice(0), compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[], added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // nextTick() would starve I/O.\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow canceled();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstInSorted(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn <T[]>array.filter(e => !!e);\n}\n\n/**\n * Remove all falsey values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): void {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * Moves the element in the array for the provided positions.\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn?: (t: T) => string): T[] {\n\tif (!keyFn) {\n\t\treturn array.filter((element, position) => {\n\t\t\treturn array.indexOf(element) === position;\n\t\t});\n\t}\n\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\treturn array.filter((elem) => {\n\t\tconst key = keyFn(elem);\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\n\t\treturn true;\n\t});\n}\n\nexport function distinctES6<T>(array: ReadonlyArray<T>): T[] {\n\tconst seen = new Set<T>();\n\treturn array.filter(element => {\n\t\tif (seen.has(element)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(element);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean {\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\t\treturn true;\n\t};\n}\n\nexport function lastIndex<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): number {\n\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function firstOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[0] : notFoundValue;\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn (<T[]>[]).concat(...arr);\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R; } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: unknown, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: unknown;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as unknown as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: any): thing is IterableIterator<T> {\n\t\treturn thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): boolean {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T) => R): Iterable<R> {\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: Iterable<T>[]): Iterable<T> {\n\t\tfor (const iterable of iterables) {\n\t\t\tfor (const element of iterable) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\nimport { Iterable } from 'vs/base/common/iterator';\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\n\nconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\nfunction markTracked<T extends IDisposable>(x: T): void {\n\tif (!TRACK_DISPOSABLES) {\n\t\treturn;\n\t}\n\n\tif (x && x !== Disposable.None) {\n\t\ttry {\n\t\t\t(x as any)[__is_disposable_tracked__] = true;\n\t\t} catch {\n\t\t\t// noop\n\t\t}\n\t}\n}\n\nfunction trackDisposable<T extends IDisposable>(x: T): T {\n\tif (!TRACK_DISPOSABLES) {\n\t\treturn x;\n\t}\n\n\tconst stack = new Error('Potentially leaked disposable').stack!;\n\tsetTimeout(() => {\n\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\tconsole.log(stack);\n\t\t}\n\t}, 3000);\n\treturn x;\n}\n\nexport class MultiDisposeError extends Error {\n\tconstructor(\n\t\tpublic readonly errors: any[]\n\t) {\n\t\tsuper(`Encounter errors while disposing of store. Errors: [${errors.join(', ')}]`);\n\t}\n}\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable>thing).dispose === 'function' && (<IDisposable>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends IterableIterator<T> = IterableIterator<T>>(disposables: IterableIterator<T>): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | IterableIterator<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tlet errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\tmarkTracked(d);\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new MultiDisposeError(errors);\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\tmarkTracked(arg);\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\n\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tdisposables.forEach(markTracked);\n\treturn trackDisposable({ dispose: () => dispose(disposables) });\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: () => {\n\t\t\tmarkTracked(self);\n\t\t\tfn();\n\t\t}\n\t});\n\treturn self;\n}\n\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkTracked(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\ttry {\n\t\t\tdispose(this._toDispose.values());\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\tpublic add<T extends IDisposable>(t: T): T {\n\t\tif (!t) {\n\t\t\treturn t;\n\t\t}\n\t\tif ((t as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tmarkTracked(t);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprivate readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkTracked(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif ((t as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(t);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tif (value) {\n\t\t\tmarkTracked(value);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\tclear() {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkTracked(this);\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = undefined;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number; }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference!.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference!.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last!.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first!.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node !== Node.Undefined; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { Disposable, IDisposable, toDisposable, combinedDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * through the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay: number = 100, leading = false, leakWarningThreshold?: number): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[] | DisposableStore) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string | undefined;\n\t\t\tlet topCount: number = 0;\n\t\t\tfor (const [stack, count] of this._stacks) {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue?: LinkedList<[Listener<T>, T]>;\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\t\tdisposables.add(result);\n\t\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = new LinkedList();\n\t\t\t}\n\n\t\t\tfor (let listener of this._listeners) {\n\t\t\t\tthis._deliveryQueue.push([listener, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.size > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners.clear();\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.clear();\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprivate _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options && options.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tconst events = this._eventQueue.toArray();\n\t\t\t\tthis._eventQueue.clear();\n\t\t\t\tsuper.fire(this._mergeFn(events));\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[Listener<T>, Omit<T, 'waitUntil'>]>;\n\n\tasync fireAsync(data: Omit<T, 'waitUntil'>, token: CancellationToken, promiseJoin?: (p: Promise<any>, listener: Function) => Promise<any>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tfor (const listener of this._listeners) {\n\t\t\tthis._asyncDeliveryQueue.push([listener, data]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<any>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\twaitUntil: (p: Promise<any>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, typeof listener === 'function' ? listener : listener[0]);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables).catch(e => onUnexpectedError(e));\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tif (this._parentListener) {\n\t\t\tthis._parentListener.dispose();\n\t\t}\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn Promise.race([promise, new Promise<T | undefined>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<any>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId: taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number) { }\n\n\tincrement(): number {\n\t\tconst now = Date.now();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isIOS = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string;\n}\n\nexport interface INodeProcess {\n\tplatform: 'win32' | 'linux' | 'darwin';\n\tenv: IProcessEnvironment;\n\tnextTick: Function;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n\tgetuid(): number;\n\tcwd(): string;\n}\ndeclare const process: INodeProcess;\ndeclare const global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n\tmaxTouchPoints?: number;\n}\ndeclare const navigator: INavigator;\ndeclare const self: any;\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof process !== 'undefined') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n} else if (typeof _globals.vscode !== 'undefined') {\n\t// Native envionment (sandboxed)\n\tnodeProcess = _globals.vscode.process;\n}\n\nconst isElectronRenderer = typeof nodeProcess?.versions?.electron === 'string' && nodeProcess.type === 'renderer';\n\n// Web environment\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n\n\t// NOTE@coder: Make languages work.\n\tconst el = typeof document !== 'undefined' && document.getElementById('vscode-remote-nls-configuration');\n\tconst rawNlsConfig = el && el.getAttribute('data-settings');\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t\t_language = nlsConfig.availableLanguages['*'] || LANGUAGE_DEFAULT;\n\t\t} catch (error) { /* Oh well. */ }\n\t}\n}\n\n// Native environment\nelse if (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isNative = _isNative;\nexport const isWeb = _isWeb;\nexport const isIOS = _isIOS;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\nexport function isRootUser(): boolean {\n\treturn !!nodeProcess && !_isWindows && (nodeProcess.getuid() === 0);\n}\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translatios that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const globals: any = _globals;\n\ninterface ISetImmediate {\n\t(callback: (...args: any[]) => void): void;\n}\n\nexport const setImmediate: ISetImmediate = (function defineSetImmediate() {\n\tif (globals.setImmediate) {\n\t\treturn globals.setImmediate.bind(globals);\n\t}\n\tif (typeof globals.postMessage === 'function' && !globals.importScripts) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tlet pending: IQueueElement[] = [];\n\t\tglobals.addEventListener('message', (e: MessageEvent) => {\n\t\t\tif (e.data && e.data.vscodeSetImmediateId) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeSetImmediateId) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\tglobals.postMessage({ vscodeSetImmediateId: myId }, '*');\n\t\t};\n\t}\n\tif (nodeProcess) {\n\t\treturn nodeProcess.nextTick.bind(nodeProcess);\n\t}\n\tconst _promise = Promise.resolve();\n\treturn (callback: (...args: any[]) => void) => _promise.then(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate, globals, INodeProcess } from 'vs/base/common/platform';\n\ndeclare const process: INodeProcess;\n\nlet safeProcess: INodeProcess;\n\n// Native node.js environment\nif (typeof process !== 'undefined') {\n\tsafeProcess = process;\n}\n\n// Native sandbox environment\nelse if (typeof globals.vscode !== 'undefined') {\n\tsafeProcess = globals.vscode.process;\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform(): 'win32' | 'linux' | 'darwin' { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tnextTick(callback: (...args: any[]) => void): void { return setImmediate(callback); },\n\n\t\t// Unsupported\n\t\tget env() { return Object.create(null); },\n\t\tcwd(): string { return '/'; },\n\t\tgetuid(): number { return -1; }\n\t};\n}\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: any) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t}\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${pathObject.ext || ''}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, 'path');\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = (process.env as any)[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\tlen > 2 &&\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisPathSeparator(path.charCodeAt(2));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tconst path = i >= 0 ? pathSegments[i] : process.cwd();\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `/${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is not an error, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t *\n\t * In case of an error, the on('error') event will be used\n\t * if the stream is flowing.\n\t */\n\tend(result?: T | Error): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T>;\n\n\treturn candidate && [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T>;\n\n\treturn candidate && isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T> {\n\t(data: T[]): T;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.listeners.data.forEach(listener => listener(data));\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.listeners.error.forEach(listener => listener(error));\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T | Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data or error if provided\n\t\tif (result instanceof Error) {\n\t\t\tthis.error(result);\n\t\t} else if (result) {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.listeners.end.forEach(listener => listener());\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.listeners.data.forEach(listener => listener(fullDataBuffer));\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.listeners.error.forEach(listener => listener(error));\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.listeners.end.forEach(listener => listener());\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T.\n */\nexport function consumeStream<T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T>): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tstream.on('data', data => chunks.push(data));\n\t\tstream.on('error', error => reject(error));\n\t\tstream.on('end', () => resolve(reducer(chunks)));\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\n\t\t// Data Listener\n\t\tconst buffer: T[] = [];\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tstream.on('data', data => target.write(transformer.data(data)));\n\tstream.on('end', () => target.end());\n\tstream.on('error', error => target.error(transformer.error ? transformer.error(error) : error));\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Constants } from 'vs/base/common/uint';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `character` occurs inside `value`.\n */\nexport function count(value: string, character: string): number {\n\tlet result = 0;\n\tconst ch = character.charCodeAt(0);\n\tfor (let i = value.length - 1; i >= 0; i--) {\n\t\tif (value.charCodeAt(i) === ch) {\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any /* standalone editor compilation */).unicode ? 'u' : '');\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 32 && isUpperAsciiLetter(codeB)) { //codeB =[65-90] && codeA =[97-122]\n\t\t\tcontinue;\n\n\t\t} else if (diff === -32 && isUpperAsciiLetter(codeA)) {  //codeB =[97-122] && codeA =[65-90]\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n\t\t\t//\n\t\t\treturn diff;\n\n\t\t} else {\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n\treturn isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n\tfor (let i = 0; i < stopAt; i++) {\n\t\tconst codeA = a.charCodeAt(i);\n\t\tconst codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// a-z A-Z\n\t\tif (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n\t\t\tconst diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Any other charcode\n\t\telse {\n\t\t\tif (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport function nextCharLength(str: string, offset: number): number {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\tconst initialOffset = offset;\n\tconst len = str.length;\n\n\tconst initialCodePoint = getNextCodePoint(str, len, offset);\n\toffset += (initialCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\n\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\n\twhile (offset < len) {\n\t\tconst nextCodePoint = getNextCodePoint(str, len, offset);\n\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);\n\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\tbreak;\n\t\t}\n\t\toffset += (nextCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t}\n\n\treturn (offset - initialOffset);\n}\n\nexport function prevCharLength(str: string, offset: number): number {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\tconst initialOffset = offset;\n\n\tconst initialCodePoint = getPrevCodePoint(str, offset);\n\toffset -= (initialCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\n\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\n\twhile (offset > 0) {\n\t\tconst prevCodePoint = getPrevCodePoint(str, offset);\n\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);\n\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\tbreak;\n\t\t}\n\t\toffset -= (prevCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t}\n\n\treturn (initialOffset - offset);\n}\n\nfunction _getCharContainingOffset(str: string, offset: number): [number, number] {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\tconst len = str.length;\n\tconst initialOffset = offset;\n\tconst initialCodePoint = getNextCodePoint(str, len, offset);\n\tconst initialGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\n\toffset += (initialCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\n\t// extend to the right\n\tlet graphemeBreakType = initialGraphemeBreakType;\n\twhile (offset < len) {\n\t\tconst nextCodePoint = getNextCodePoint(str, len, offset);\n\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);\n\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\tbreak;\n\t\t}\n\t\toffset += (nextCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t}\n\tconst endOffset = offset;\n\n\t// extend to the left\n\toffset = initialOffset;\n\tgraphemeBreakType = initialGraphemeBreakType;\n\twhile (offset > 0) {\n\t\tconst prevCodePoint = getPrevCodePoint(str, offset);\n\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);\n\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\tbreak;\n\t\t}\n\t\toffset -= (prevCodePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t}\n\n\treturn [offset, endOffset];\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\treturn _getCharContainingOffset(str, offset - 1);\n\t}\n\treturn _getCharContainingOffset(str, offset);\n}\n\n/**\n * A manual encoding of `str` to UTF8.\n * Use only in environments which do not offer native conversion methods!\n */\nexport function encodeUTF8(str: string): Uint8Array {\n\tconst strLen = str.length;\n\n\t// See https://en.wikipedia.org/wiki/UTF-8\n\n\t// first loop to establish needed buffer size\n\tlet neededSize = 0;\n\tlet strOffset = 0;\n\twhile (strOffset < strLen) {\n\t\tconst codePoint = getNextCodePoint(str, strLen, strOffset);\n\t\tstrOffset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\n\t\tif (codePoint < 0x0080) {\n\t\t\tneededSize += 1;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tneededSize += 2;\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tneededSize += 3;\n\t\t} else {\n\t\t\tneededSize += 4;\n\t\t}\n\t}\n\n\t// second loop to actually encode\n\tconst arr = new Uint8Array(neededSize);\n\tstrOffset = 0;\n\tlet arrOffset = 0;\n\twhile (strOffset < strLen) {\n\t\tconst codePoint = getNextCodePoint(str, strLen, strOffset);\n\t\tstrOffset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\n\t\tif (codePoint < 0x0080) {\n\t\t\tarr[arrOffset++] = codePoint;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tarr[arrOffset++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tarr[arrOffset++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else {\n\t\t\tarr[arrOffset++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tarr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t}\n\t}\n\n\treturn arr;\n}\n\n/**\n * A manual decoding of a UTF8 string.\n * Use only in environments which do not offer native conversion methods!\n */\nexport function decodeUTF8(buffer: Uint8Array): string {\n\t// https://en.wikipedia.org/wiki/UTF-8\n\n\tconst len = buffer.byteLength;\n\tconst result: string[] = [];\n\tlet offset = 0;\n\twhile (offset < len) {\n\t\tconst v0 = buffer[offset];\n\t\tlet codePoint: number;\n\t\tif (v0 >= 0b11110000 && offset + 3 < len) {\n\t\t\t// 4 bytes\n\t\t\tcodePoint = (\n\t\t\t\t(((buffer[offset++] & 0b00000111) << 18) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 12) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 6) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 0) >>> 0)\n\t\t\t);\n\t\t} else if (v0 >= 0b11100000 && offset + 2 < len) {\n\t\t\t// 3 bytes\n\t\t\tcodePoint = (\n\t\t\t\t(((buffer[offset++] & 0b00001111) << 12) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 6) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 0) >>> 0)\n\t\t\t);\n\t\t} else if (v0 >= 0b11000000 && offset + 1 < len) {\n\t\t\t// 2 bytes\n\t\t\tcodePoint = (\n\t\t\t\t(((buffer[offset++] & 0b00011111) << 6) >>> 0)\n\t\t\t\t| (((buffer[offset++] & 0b00111111) << 0) >>> 0)\n\t\t\t);\n\t\t} else {\n\t\t\t// 1 byte\n\t\t\tcodePoint = buffer[offset++];\n\t\t}\n\n\t\tif ((codePoint >= 0 && codePoint <= 0xD7FF) || (codePoint >= 0xE000 && codePoint <= 0xFFFF)) {\n\t\t\t// Basic Multilingual Plane\n\t\t\tresult.push(String.fromCharCode(codePoint));\n\t\t} else if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t// Supplementary Planes\n\t\t\tconst uPrime = codePoint - 0x10000;\n\t\t\tconst w1 = 0xD800 + ((uPrime & 0b11111111110000000000) >>> 10);\n\t\t\tconst w2 = 0xDC00 + ((uPrime & 0b00000000001111111111) >>> 0);\n\t\t\tresult.push(String.fromCharCode(w1));\n\t\t\tresult.push(String.fromCharCode(w2));\n\t\t} else {\n\t\t\t// illegal code point\n\t\t\tresult.push(String.fromCharCode(0xFFFD));\n\t\t}\n\t}\n\n\treturn result.join('');\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD00-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE82\\uDE90-\\uDE95])/;\n\nexport function containsEmoji(str: string): boolean {\n\treturn CONTAINS_EMOJI.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function containsFullWidthCharacter(str: string): boolean {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (isFullWidthCharacter(str.charCodeAt(i))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80  2EFF   CJK Radicals Supplement\n\t//          2F00  2FDF   Kangxi Radicals\n\t//          2FF0  2FFF   Ideographic Description Characters\n\t//          3000  303F   CJK Symbols and Punctuation\n\t//          3040  309F   Hiragana\n\t//          30A0  30FF   Katakana\n\t//          3100  312F   Bopomofo\n\t//          3130  318F   Hangul Compatibility Jamo\n\t//          3190  319F   Kanbun\n\t//          31A0  31BF   Bopomofo Extended\n\t//          31F0  31FF   Katakana Phonetic Extensions\n\t//          3200  32FF   Enclosed CJK Letters and Months\n\t//          3300  33FF   CJK Compatibility\n\t//          3400  4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0  4DFF   Yijing Hexagram Symbols\n\t//          4E00  9FFF   CJK Unified Ideographs\n\t//          A000  A48F   Yi Syllables\n\t//          A490  A4CF   Yi Radicals\n\t//          AC00  D7AF   Hangul Syllables\n\t// [IGNORE] D800  DB7F   High Surrogates\n\t// [IGNORE] DB80  DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00  DFFF   Low Surrogates\n\t// [IGNORE] E000  F8FF   Private Use Area\n\t//          F900  FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00  FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50  FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00  FE0F   Variation Selectors\n\t// [IGNORE] FE20  FE2F   Combining Half Marks\n\t// [IGNORE] FE30  FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50  FE6F   Small Form Variants\n\t// [IGNORE] FE70  FEFF   Arabic Presentation Forms-B\n\t//          FF00  FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0  FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x >= 9728 && x <= 10175) || (x >= 127744 && x <= 128591)\n\t\t|| (x >= 128640 && x <= 128764) || (x >= 128992 && x <= 129003) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129651) || (x >= 129656 && x <= 129666) || (x >= 129680 && x <= 129685)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, '');\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\treturn idx >= 0 ?\n\t\tstr.substr(0, idx) :\n\t\tstr;\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nexport function breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR  LF\n\t// GB4                       (Control | CR | LF) \n\t// GB5                                            (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L  (L | V | LV | LVT)\n\t// GB7                                  (LV | V)  (V | T)\n\t// GB8                                 (LVT | T)  T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                            (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                           SpacingMark\n\t// GB9b                                  Prepend \n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ  \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI  RI\n\t// GB13                        [^RI] (RI RI)* RI  RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any  Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-grapheme-break.js\n\treturn JSON.parse('[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]');\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst hasTextEncoder = (typeof TextEncoder !== 'undefined');\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\tstatic fromString(source: string): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else if (hasTextEncoder) {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t} else {\n\t\t\treturn new VSBuffer(strings.encodeUTF8(source));\n\t\t}\n\t}\n\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else if (hasTextDecoder) {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t} else {\n\t\t\treturn strings.decodeUTF8(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performant, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start!/*bad lib.d.ts*/, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else {\n\t\t\tthis.buffer.set(array, offset);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray<T>(array: T | {}): array is T extends readonly any[] ? (unknown extends T ? never : readonly any[]) : any[] {\n\treturn Array.isArray(array);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: any): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: any): value is string[] {\n\treturn Array.isArray(value) && (<any[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: any): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: any): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: any): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: any): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: any): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: any, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined<T>(arg: T | null | undefined): T {\n\tif (isUndefinedOrNull(arg)) {\n\t\tthrow new Error('Assertion Failed: argument is undefined or null');\n\t}\n\n\treturn arg;\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: any): obj is any {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (let key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: any): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: any[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: any[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: any, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\nexport function getAllPropertyNames(obj: object): string[] {\n\tlet res: string[] = [];\n\tlet proto = Object.getPrototypeOf(obj);\n\twhile (Object.prototype !== proto) {\n\t\tres = res.concat(Object.getOwnPropertyNames(proto));\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn res;\n}\n\nexport function getAllMethodNames(obj: object): string[] {\n\tconst methods: string[] = [];\n\tfor (const prop of getAllPropertyNames(obj)) {\n\t\tif (typeof (obj as any)[prop] === 'function') {\n\t\t\tmethods.push(prop);\n\t\t}\n\t}\n\treturn methods;\n}\n\nexport function createProxyObject<T extends object>(methodNames: string[], invoke: (method: string, args: any[]) => any): T {\n\tconst createProxyMethod = (method: string): () => any => {\n\t\treturn function () {\n\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\treturn invoke(method, args);\n\t\t};\n\t};\n\n\tlet result = {} as T;\n\tfor (const methodName of methodNames) {\n\t\t(<any>result)[methodName] = createProxyMethod(methodName);\n\t}\n\treturn result;\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n\treturn x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n\treturn typeof x === 'undefined' ? null : x;\n}\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\n\t//  For every property\n\t[K in keyof Target]:\n\n\t// Function: add param to function\n\tTarget[K] extends (...args: any) => TargetFunctionsReturnType ? (firstArg: FirstParameter, ...args: Parameters<Target[K]>) => ReturnType<Target[K]> :\n\n\t// Else: just leave as is\n\tTarget[K]\n};\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents and\n * drops all functions.\n */\nexport type Dto<T> = T extends { toJSON(): infer U }\n\t? U\n\t: T extends object\n\t? { [k in keyof T]: Dto<T[k]>; }\n\t: T;\n\nexport function NotImplementedProxy<T>(name: string): { new(): T } {\n\treturn <any>class {\n\t\tconstructor() {\n\t\t\treturn new Proxy({}, {\n\t\t\t\tget(target: any, prop: PropertyKey) {\n\t\t\t\t\tif (target[prop]) {\n\t\t\t\t\t\treturn target[prop];\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Not Implemented: ${name}->${String(prop)}`);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tsegments.forEach(segment => {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t});\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isUndefinedOrNull, isArray } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(<any>obj).forEach((key: string) => {\n\t\tif ((<any>obj)[key] && typeof (<any>obj)[key] === 'object') {\n\t\t\tresult[key] = deepClone((<any>obj)[key]);\n\t\t} else {\n\t\t\tresult[key] = (<any>obj)[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (let i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Calls `JSON.Stringify` with a replacer to break apart any circular references.\n * This prevents `JSON`.stringify` from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen = new Set<any>();\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.has(value)) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.add(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T, R>(obj: T, fn: (obj: T) => R | undefined, defaultValue: R): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\ntype obj = { [key: string]: any; };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n\nexport function getCaseInsensitive(target: obj, key: string): any {\n\tconst lowercaseKey = key.toLowerCase();\n\tconst equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);\n\treturn equivalentKey ? target[equivalentKey] : target[key];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as paths from 'vs/base/common/path';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'function'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\treturn new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPaths on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatibile with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\tget fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\ttoString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\ttoJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\ninterface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[], stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t};\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color(''), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color(''), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tif (typeof (console as any)[entry.severity] !== 'function') {\n\t\tthrow new Error('Unknown console method');\n\t}\n\t(console as any)[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { regExpFlags } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\n\nexport function stringify(obj: any): string {\n\treturn JSON.stringify(obj, replacer);\n}\n\nexport function parse(text: string): any {\n\tlet data = JSON.parse(text);\n\tdata = revive(data);\n\treturn data;\n}\n\nexport interface MarshalledObject {\n\t$mid: number;\n}\n\nfunction replacer(key: string, value: any): any {\n\t// URI is done via toJSON-member\n\tif (value instanceof RegExp) {\n\t\treturn {\n\t\t\t$mid: 2,\n\t\t\tsource: value.source,\n\t\t\tflags: regExpFlags(value),\n\t\t};\n\t}\n\treturn value;\n}\n\n\ntype Deserialize<T> = T extends UriComponents ? URI\n\t: T extends object\n\t? Revived<T>\n\t: T;\n\nexport type Revived<T> = { [K in keyof T]: Deserialize<T[K]> };\n\nexport function revive<T = any>(obj: any, depth = 0): Revived<T> {\n\tif (!obj || depth > 200) {\n\t\treturn obj;\n\t}\n\n\tif (typeof obj === 'object') {\n\n\t\tswitch ((<MarshalledObject>obj).$mid) {\n\t\t\tcase 1: return <any>URI.revive(obj);\n\t\t\tcase 2: return <any>new RegExp(obj.source, obj.flags);\n\t\t}\n\n\t\tif (\n\t\t\tobj instanceof VSBuffer\n\t\t\t|| obj instanceof Uint8Array\n\t\t) {\n\t\t\treturn <any>obj;\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tfor (let i = 0; i < obj.length; ++i) {\n\t\t\t\tobj[i] = revive(obj[i], depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// walk object\n\t\t\tfor (const key in obj) {\n\t\t\t\tif (Object.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\tobj[key] = revive(obj[key], depth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebook = 'vscode-notebook';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for loading resources inside of webviews.\n\t */\n\texport const vscodeWebviewResource = 'vscode-webview-resource';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\t// const port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\t// NOTE@coder: Changed this to work against the current path.\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: window.location.host,\n\t\t\tpath: `${window.location.pathname.replace(/\\/+$/, '')}/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nclass FileAccessImpl {\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(uri: URI): URI;\n\tasBrowserUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasBrowserUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(uri: URI): URI;\n\tasFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl!.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compareSubstringIgnoreCase, compare, compareSubstring, compareIgnoreCase } from 'vs/base/common/strings';\nimport { isLinux } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(private readonly _ignorePathCasing: boolean | undefined) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, this._ignorePathCasing === undefined\n\t\t\t\t? key.scheme === Schemas.file && isLinux\n\t\t\t\t: !this._ignorePathCasing\n\t\t\t);\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (this._value.query) {\n\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t}\n\t\tif (this._value.fragment) {\n\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\tsegment!: string;\n\tvalue: V | undefined;\n\tkey!: K;\n\tleft: TernarySearchTreeNode<K, V> | undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing?: boolean): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing));\n\t}\n\n\tstatic forPaths<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && (node.isEmpty() || superStr)) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: K): Iterator<V> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._values(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => any): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate *_values(node: TernarySearchTreeNode<K, V>): IterableIterator<V> {\n\t\tfor (const [, value] of this._entries(node)) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\tprivate *_entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tyield* this._entries(node.left);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tyield [node.key, node.value];\n\t\t\t}\n\t\t\t// mid\n\t\t\tyield* this._entries(node.mid);\n\n\t\t\t// right\n\t\t\tyield* this._entries(node.right);\n\t\t}\n\t}\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, T>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), value);\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (let [index, value] of this.map) {\n\t\t\tclb(value, URI.parse(index), <any>this);\n\t\t}\n\t}\n\n\tvalues(): IterableIterator<T> {\n\t\treturn this.map.values();\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (let key of this.map.keys()) {\n\t\t\tyield URI.parse(key);\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (let tuple of this.map.entries()) {\n\t\t\tyield [URI.parse(tuple[0]), tuple[1]];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (let item of this.map) {\n\t\t\tyield [URI.parse(item[0]), item[1]];\n\t\t}\n\t}\n}\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || path.endsWith(nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from 'vs/base/common/map';\n\n/**\n * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\n * the Normalization Form Canonical Composition.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\n */\nexport const canNormalize = typeof (String.prototype as any /* standalone editor compilation */).normalize === 'function';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!canNormalize || !str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = (<any>str).normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\tif (!canNormalize) {\n\t\t// no ES6 features...\n\t\treturn function (str: string) { return str; };\n\t} else {\n\t\t// transform into NFD form and remove accents\n\t\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\t\tconst regex = /[\\u0300-\\u036f]/g;\n\t\treturn function (str: string) {\n\t\t\treturn normalizeNFD(str).replace(regex, '');\n\t\t};\n\t}\n})();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nexport function isUUID(value: string): boolean {\n\treturn _UUIDPattern.test(value);\n}\n\n// prep-work\nconst _data = new Uint8Array(16);\nconst _hex: string[] = [];\nfor (let i = 0; i < 256; i++) {\n\t_hex.push(i.toString(16).padStart(2, '0'));\n}\n\n// todo@joh node nodejs use `crypto#randomBytes`, see: https://nodejs.org/docs/latest/api/crypto.html#crypto_crypto_randombytes_size_callback\n// todo@joh use browser-crypto\nconst _fillRandomValues = function (bucket: Uint8Array): Uint8Array {\n\tfor (let i = 0; i < bucket.length; i++) {\n\t\tbucket[i] = Math.floor(Math.random() * 256);\n\t}\n\treturn bucket;\n};\n\nexport function generateUuid(): string {\n\t// get data\n\t_fillRandomValues(_data);\n\n\t// set version bits\n\t_data[6] = (_data[6] & 0x0f) | 0x40;\n\t_data[8] = (_data[8] & 0x3f) | 0x80;\n\n\t// print as string\n\tlet i = 0;\n\tlet result = '';\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += '-';\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += '-';\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += '-';\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += '-';\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\tresult += _hex[_data[i++]];\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.StringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: string = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\twrite(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tend(): string | null {\n\t\treturn this.remaining;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { join } from 'vs/base/common/path';\nimport { Queue } from 'vs/base/common/async';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as platform from 'vs/base/common/platform';\nimport { Event } from 'vs/base/common/event';\nimport { promisify } from 'util';\nimport { isRootOrDriveLetter } from 'vs/base/common/extpath';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { normalizeNFC } from 'vs/base/common/normalization';\n\n// See https://github.com/microsoft/vscode/issues/30180\nconst WIN32_MAX_FILE_SIZE = 300 * 1024 * 1024; // 300 MB\nconst GENERAL_MAX_FILE_SIZE = 16 * 1024 * 1024 * 1024; // 16 GB\n\n// See https://github.com/v8/v8/blob/5918a23a3d571b9625e5cce246bdd5b46ff7cd8b/src/heap/heap.cc#L149\nconst WIN32_MAX_HEAP_SIZE = 700 * 1024 * 1024; // 700 MB\nconst GENERAL_MAX_HEAP_SIZE = 700 * 2 * 1024 * 1024; // 1400 MB\n\nexport const MAX_FILE_SIZE = process.arch === 'ia32' ? WIN32_MAX_FILE_SIZE : GENERAL_MAX_FILE_SIZE;\nexport const MAX_HEAP_SIZE = process.arch === 'ia32' ? WIN32_MAX_HEAP_SIZE : GENERAL_MAX_HEAP_SIZE;\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\nexport async function rimraf(path: string, mode = RimRafMode.UNLINK): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via unlink\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path);\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\ttry {\n\t\tconst stat = await lstat(path);\n\n\t\t// Folder delete (recursive) - NOT for symbolic links though!\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\n\t\t\t// Children\n\t\t\tconst children = await readdir(path);\n\t\t\tawait Promise.all(children.map(child => rimrafUnlink(join(path, child))));\n\n\t\t\t// Folder\n\t\t\tawait promisify(fs.rmdir)(path);\n\t\t}\n\n\t\t// Single file delete\n\t\telse {\n\n\t\t\t// chmod as needed to allow for unlink\n\t\t\tconst mode = stat.mode;\n\t\t\tif (!(mode & 128)) { // 128 === 0200\n\t\t\t\tawait chmod(path, mode | 128);\n\t\t\t}\n\n\t\t\treturn unlink(path);\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafMove(path: string): Promise<void> {\n\ttry {\n\t\tconst pathInTemp = join(os.tmpdir(), generateUuid());\n\t\ttry {\n\t\t\tawait rename(path, pathInTemp);\n\t\t} catch (error) {\n\t\t\treturn rimrafUnlink(path); // if rename fails, delete without tmp dir\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(pathInTemp);\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\ttry {\n\t\tconst stat = fs.lstatSync(path);\n\n\t\t// Folder delete (recursive) - NOT for symbolic links though!\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\n\t\t\t// Children\n\t\t\tconst children = readdirSync(path);\n\t\t\tchildren.map(child => rimrafSync(join(path, child)));\n\n\t\t\t// Folder\n\t\t\tfs.rmdirSync(path);\n\t\t}\n\n\t\t// Single file delete\n\t\telse {\n\n\t\t\t// chmod as needed to allow for unlink\n\t\t\tconst mode = stat.mode;\n\t\t\tif (!(mode & 128)) { // 128 === 0200\n\t\t\t\tfs.chmodSync(path, mode | 128);\n\t\t\t}\n\n\t\t\treturn fs.unlinkSync(path);\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport async function readdir(path: string): Promise<string[]> {\n\treturn handleDirectoryChildren(await promisify(fs.readdir)(path));\n}\n\nexport async function readdirWithFileTypes(path: string): Promise<fs.Dirent[]> {\n\tconst children = await promisify(fs.readdir)(path, { withFileTypes: true });\n\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\tfor (const child of children) {\n\t\t\tchild.name = normalizeNFC(child.name);\n\t\t}\n\t}\n\n\treturn children;\n}\n\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[] {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn children.map(child => normalizeNFC(child));\n\t}\n\n\treturn children;\n}\n\nexport function exists(path: string): Promise<boolean> {\n\treturn promisify(fs.exists)(path);\n}\n\nexport function chmod(path: string, mode: number): Promise<void> {\n\treturn promisify(fs.chmod)(path, mode);\n}\n\nexport function stat(path: string): Promise<fs.Stats> {\n\treturn promisify(fs.stat)(path);\n}\n\nexport interface IStatAndLink {\n\n\t// The stats of the file. If the file is a symbolic\n\t// link, the stats will be of that target file and\n\t// not the link itself.\n\t// If the file is a symbolic link pointing to a non\n\t// existing file, the stat will be of the link and\n\t// the `dangling` flag will indicate this.\n\tstat: fs.Stats;\n\n\t// Will be provided if the resource is a symbolic link\n\t// on disk. Use the `dangling` flag to find out if it\n\t// points to a resource that does not exist on disk.\n\tsymbolicLink?: { dangling: boolean };\n}\n\nexport async function statLink(path: string): Promise<IStatAndLink> {\n\n\t// First stat the link\n\tlet lstats: fs.Stats | undefined;\n\ttry {\n\t\tlstats = await lstat(path);\n\n\t\t// Return early if the stat is not a symbolic link at all\n\t\tif (!lstats.isSymbolicLink()) {\n\t\t\treturn { stat: lstats };\n\t\t}\n\t} catch (error) {\n\t\t/* ignore - use stat() instead */\n\t}\n\n\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t// which for symbolic links will stat the target they point to\n\ttry {\n\t\tconst stats = await stat(path);\n\n\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t} catch (error) {\n\n\t\t// If the link points to a non-existing file we still want\n\t\t// to return it as result while setting dangling: true flag\n\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function lstat(path: string): Promise<fs.Stats> {\n\treturn promisify(fs.lstat)(path);\n}\n\nexport function rename(oldPath: string, newPath: string): Promise<void> {\n\treturn promisify(fs.rename)(oldPath, newPath);\n}\n\nexport function renameIgnoreError(oldPath: string, newPath: string): Promise<void> {\n\treturn new Promise(resolve => fs.rename(oldPath, newPath, () => resolve()));\n}\n\nexport function unlink(path: string): Promise<void> {\n\treturn promisify(fs.unlink)(path);\n}\n\nexport function symlink(target: string, path: string, type?: string): Promise<void> {\n\treturn promisify(fs.symlink)(target, path, type);\n}\n\nexport function truncate(path: string, len: number): Promise<void> {\n\treturn promisify(fs.truncate)(path, len);\n}\n\nexport function readFile(path: string): Promise<Buffer>;\nexport function readFile(path: string, encoding: string): Promise<string>;\nexport function readFile(path: string, encoding?: string): Promise<Buffer | string> {\n\treturn promisify(fs.readFile)(path, encoding);\n}\n\nexport async function mkdirp(path: string, mode?: number): Promise<void> {\n\treturn promisify(fs.mkdir)(path, { mode, recursive: true });\n}\n\n// According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeFilePathQueues: Map<string, Queue<void>> = new Map();\n\nexport function writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\tconst queueKey = toQueueKey(path);\n\n\treturn ensureWriteFileQueue(queueKey).queue(() => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t});\n}\n\nfunction toQueueKey(path: string): string {\n\tlet queueKey = path;\n\tif (platform.isWindows || platform.isMacintosh) {\n\t\tqueueKey = queueKey.toLowerCase(); // accommodate for case insensitive file systems\n\t}\n\n\treturn queueKey;\n}\n\nfunction ensureWriteFileQueue(queueKey: string): Queue<void> {\n\tconst existingWriteFileQueue = writeFilePathQueues.get(queueKey);\n\tif (existingWriteFileQueue) {\n\t\treturn existingWriteFileQueue;\n\t}\n\n\tconst writeFileQueue = new Queue<void>();\n\twriteFilePathQueues.set(queueKey, writeFileQueue);\n\n\tconst onFinish = Event.once(writeFileQueue.onFinished);\n\tonFinish(() => {\n\t\twriteFilePathQueues.delete(queueKey);\n\t\twriteFileQueue.dispose();\n\t});\n\n\treturn writeFileQueue;\n}\n\nexport interface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd);\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tcanFlush = false;\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\nexport async function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await dirExists(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\nexport async function dirExists(path: string): Promise<boolean> {\n\ttry {\n\t\tconst fileStat = await stat(path);\n\n\t\treturn fileStat.isDirectory();\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\nexport async function fileExists(path: string): Promise<boolean> {\n\ttry {\n\t\tconst fileStat = await stat(path);\n\n\t\treturn fileStat.isFile();\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\nexport function whenDeleted(path: string): Promise<void> {\n\n\t// Complete when wait marker file is deleted\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.exists(path, exists => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n}\n\nexport async function move(source: string, target: string): Promise<void> {\n\tif (source === target) {\n\t\treturn Promise.resolve();\n\t}\n\n\tasync function updateMtime(path: string): Promise<void> {\n\t\tconst stat = await lstat(path);\n\t\tif (stat.isDirectory() || stat.isSymbolicLink()) {\n\t\t\treturn Promise.resolve(); // only for files\n\t\t}\n\n\t\tconst fd = await promisify(fs.open)(path, 'a');\n\t\ttry {\n\t\t\tawait promisify(fs.futimes)(fd, stat.atime, new Date());\n\t\t} catch (error) {\n\t\t\t//ignore\n\t\t}\n\n\t\treturn promisify(fs.close)(fd);\n\t}\n\n\ttry {\n\t\tawait rename(source, target);\n\t\tawait updateMtime(target);\n\t} catch (error) {\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target);\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t\tawait updateMtime(target);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport async function copy(source: string, target: string, copiedSourcesIn?: { [path: string]: boolean }): Promise<void> {\n\tconst copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n\n\tconst fileStat = await stat(source);\n\tif (!fileStat.isDirectory()) {\n\t\treturn doCopyFile(source, target, fileStat.mode & 511);\n\t}\n\n\tif (copiedSources[source]) {\n\t\treturn Promise.resolve(); // escape when there are cycles (can happen with symlinks)\n\t}\n\n\tcopiedSources[source] = true; // remember as copied\n\n\t// Create folder\n\tawait mkdirp(target, fileStat.mode & 511);\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (let i = 0; i < files.length; i++) {\n\t\tconst file = files[i];\n\t\tawait copy(join(source, file), join(target, file), copiedSources);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst reader = fs.createReadStream(source);\n\t\tconst writer = fs.createWriteStream(target, { mode });\n\n\t\tlet finished = false;\n\t\tconst finish = (error?: Error) => {\n\t\t\tif (!finished) {\n\t\t\t\tfinished = true;\n\n\t\t\t\t// in error cases, pass to callback\n\t\t\t\tif (error) {\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\t// we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n\t\t\t\tfs.chmod(target, mode, error => error ? reject(error) : resolve());\n\t\t\t}\n\t\t};\n\n\t\t// handle errors properly\n\t\treader.once('error', error => finish(error));\n\t\twriter.once('error', error => finish(error));\n\n\t\t// we are done (underlying fd has been closed)\n\t\twriter.once('close', () => finish());\n\n\t\t// start piping\n\t\treader.pipe(writer);\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { rtrim } from 'vs/base/common/strings';\nimport { sep, join, normalize, dirname, basename } from 'vs/base/common/path';\nimport { readdirSync } from 'vs/base/node/pfs';\nimport { promisify } from 'util';\n\n/**\n * Copied from: https://github.com/microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realpath(path: string): Promise<string> {\n\ttry {\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait promisify(fs.access)(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter, Relay, EventMultiplexer } from 'vs/base/common/event';\nimport { IDisposable, toDisposable, combinedDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { getRandomElement } from 'vs/base/common/arrays';\nimport { isFunction, isUndefinedOrNull } from 'vs/base/common/types';\nimport { revive } from 'vs/base/common/marshalling';\nimport * as strings from 'vs/base/common/strings';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5\n}\n\nfunction createSizeBuffer(size: number): VSBuffer {\n\tconst result = VSBuffer.alloc(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriter.write(createSizeBuffer(data.byteLength));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay: number = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\t}\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\t}\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\t}\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\t}\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => { this.activeRequests.delete(disposable); });\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\t}\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\t}\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tlet connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables = new DisposableStore();\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tthis._connections.forEach(connection => {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n\n//#region createChannelReceiver / createChannelSender\n\n/**\n * Use both `createChannelReceiver` and `createChannelSender`\n * for automated process <=> process communication over methods\n * and events. You do not need to spell out each method on both\n * sides, a proxy will take care of this.\n *\n * Rules:\n * - if marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - events must follow the naming convention `onUppercase`\n * - `CancellationToken` is currently not supported\n * - if a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\n\nexport interface IBaseChannelOptions {\n\n\t/**\n\t * Disables automatic marshalling of `URI`.\n\t * If marshalling is disabled, `UriComponents`\n\t * must be used instead.\n\t */\n\tdisableMarshalling?: boolean;\n}\n\nexport interface IChannelReceiverOptions extends IBaseChannelOptions { }\n\nexport function createChannelReceiver(service: unknown, options?: IChannelReceiverOptions): IServerChannel {\n\tconst handler = service as { [key: string]: unknown };\n\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t// Buffer any event that should be supported by\n\t// iterating over all property keys and finding them\n\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\tfor (const key in handler) {\n\t\tif (propertyIsEvent(key)) {\n\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true));\n\t\t}\n\t}\n\n\treturn new class implements IServerChannel {\n\n\t\tlisten<T>(_: unknown, event: string): Event<T> {\n\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\tif (eventImpl) {\n\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t}\n\n\t\t\tthrow new Error(`Event not found: ${event}`);\n\t\t}\n\n\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\tconst target = handler[command];\n\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn target.apply(handler, args);\n\t\t\t}\n\n\t\t\tthrow new Error(`Method not found: ${command}`);\n\t\t}\n\t};\n}\n\nexport interface IChannelSenderOptions extends IBaseChannelOptions {\n\n\t/**\n\t * If provided, will add the value of `context`\n\t * to each method call to the target.\n\t */\n\tcontext?: unknown;\n\n\t/**\n\t * If provided, will not proxy any of the properties\n\t * that are part of the Map but rather return that value.\n\t */\n\tproperties?: Map<string, unknown>;\n}\n\nexport function createChannelSender<T>(channel: IChannel, options?: IChannelSenderOptions): T {\n\tconst disableMarshalling = options && options.disableMarshalling;\n\n\treturn new Proxy({}, {\n\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t// Check for predefined values\n\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t}\n\n\t\t\t\t// Event\n\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t}\n\n\t\t\t\t// Function\n\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t// Add context if any\n\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Property not found: ${String(propKey)}`);\n\t\t}\n\t}) as T;\n}\n\nfunction propertyIsEvent(name: string): boolean {\n\t// Assume a property is an event if it has a form of \"onSomething\"\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n}\n\n//#endregion\n\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tlet result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nexport function logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport { promisify } from 'util';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { FileAccess } from 'vs/base/common/network';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nfunction terminateProcess(process: cp.ChildProcess, cwd?: string): Promise<TerminateResponse> {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tconst killProcess = cp.execFile('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tkillProcess.once('error', (err) => {\n\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t});\n\t\t\t\tkillProcess.once('exit', (code, signal) => {\n\t\t\t\t\tif (code === 0) {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: false, code: code !== null ? code : TerminateResponseCode.Unknown });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown });\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = FileAccess.asFileUri('vs/base/node/terminateProcess.sh', require).fsPath;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tcp.execFile(cmd, [process.pid.toString()], { encoding: 'utf8', shell: true } as cp.ExecFileOptions, (err, stdout, stderr) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err });\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn Promise.resolve({ success: true });\n}\n\nexport function getWindowsShell(environment: Platform.IProcessEnvironment = process.env as Platform.IProcessEnvironment): string {\n\treturn environment['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve: ValueCallback<number> | undefined;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.childProcessPromise = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\treturn terminateProcess(childProcess, this.options.cwd).then(response => {\n\t\t\t\tif (response.success) {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t});\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn resolve(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn resolve(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn resolve(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder | null;\n\tprivate stderrLineDecoder: LineDecoder | null;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\n\t\tthis.stdoutLineDecoder = null;\n\t\tthis.stderrLineDecoder = null;\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tconst stdoutLineDecoder = new LineDecoder();\n\t\tconst stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\n\t\tthis.stdoutLineDecoder = stdoutLineDecoder;\n\t\tthis.stderrLineDecoder = stderrLineDecoder;\n\t}\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\tconst stdoutLine = this.stdoutLineDecoder ? this.stdoutLineDecoder.end() : null;\n\t\tif (stdoutLine) {\n\t\t\tpp({ line: stdoutLine, source: Source.stdout });\n\t\t}\n\t\tconst stderrLine = this.stderrLineDecoder ? this.stderrLineDecoder.end() : null;\n\t\tif (stderrLine) {\n\t\t\tpp({ line: stderrLine, source: Source.stderr });\n\t\t}\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env.PATH)) {\n\t\t\tpaths = process.env.PATH.split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await promisify(fs.exists)(path)) {\n\t\t\t\treturn !((await promisify(fs.stat)(path)).isDirectory());\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { IChannel, ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient } from 'vs/base/parts/ipc/common/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/common/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { isMacintosh } from 'vs/base/common/platform';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send((<Buffer>r.buffer).toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => VSBuffer.wrap(Buffer.from(msg, 'base64')))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * See https://github.com/microsoft/vscode/issues/27665\n\t * Allows to pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n\t * e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n\t * results in the forked process inheriting `--inspect-brk=xxx`.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void> | undefined;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate readonly _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = { ...deepClone(process.env), 'VSCODE_PARENT_PID': String(process.pid) };\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = { ...forkOpts.env, ...this.options.env };\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tif (isMacintosh && forkOpts.env) {\n\t\t\t\t// Unset `DYLD_LIBRARY_PATH`, as it leads to process crashes\n\t\t\t\t// See https://github.com/microsoft/vscode/issues/105848\n\t\t\t\tdelete forkOpts.env['DYLD_LIBRARY_PATH'];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<VSBuffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(VSBuffer.wrap(Buffer.from(msg, 'base64')));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: VSBuffer) => this.child && this.child.connected && sender.send((<Buffer>r.buffer).toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit' as 'loaded', onExit); // https://github.com/electron/electron/issues/21475\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tif (this.disposeDelayer) {\n\t\t\tthis.disposeDelayer.cancel();\n\t\t\tthis.disposeDelayer = undefined;\n\t\t}\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew <Services extends BrandedService[]>(first: A1, ...services: Services): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: BrandedService[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tget<T>(id: ServiceIdentifier<T>, isOptional: typeof optional): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\ntype GetLeadingNonServiceArgs<Args> =\n\tArgs extends [...BrandedService[]] ? []\n\t: Args extends [infer A1, ...BrandedService[]] ? [A1]\n\t: Args extends [infer A1, infer A2, ...BrandedService[]] ? [A1, A2]\n\t: Args extends [infer A1, infer A2, infer A3, ...BrandedService[]] ? [A1, A2, A3]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, ...BrandedService[]] ? [A1, A2, A3, A4]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, ...BrandedService[]] ? [A1, A2, A3, A4, A5]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6, A7]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, infer A8, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6, A7, A8]\n\t: never;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(t: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { sep } from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport * as glob from 'vs/base/common/glob';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event } from 'vs/base/common/event';\nimport { startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { isNumber, isUndefinedOrNull } from 'vs/base/common/types';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { ReadableStreamEvents } from 'vs/base/common/stream';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport const IFileService = createDecorator<IFileService>('fileService');\n\nexport interface IFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that is fired when a file system provider is added or removed\n\t */\n\treadonly onDidChangeFileSystemProviderRegistrations: Event<IFileSystemProviderRegistrationEvent>;\n\n\t/**\n\t * An event that is fired when a registered file system provider changes it's capabilities.\n\t */\n\treadonly onDidChangeFileSystemProviderCapabilities: Event<IFileSystemProviderCapabilitiesChangeEvent>;\n\n\t/**\n\t * An event that is fired when a file system provider is about to be activated. Listeners\n\t * can join this event with a long running promise to help in the activation process.\n\t */\n\treadonly onWillActivateFileSystemProvider: Event<IFileSystemProviderActivationEvent>;\n\n\t/**\n\t * Registers a file system provider for a certain scheme.\n\t */\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable;\n\n\t/**\n\t * Tries to activate a provider with the given scheme.\n\t */\n\tactivateProvider(scheme: string): Promise<void>;\n\n\t/**\n\t * Checks if this file service can handle the given resource.\n\t */\n\tcanHandleResource(resource: URI): boolean;\n\n\t/**\n\t * Checks if the provider for the provided resource has the provided file system capability.\n\t */\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;\n\n\t/**\n\t * List the schemes and capabilies for registered file system providers\n\t */\n\tlistCapabilities(): Iterable<{ scheme: string, capabilities: FileSystemProviderCapabilities }>\n\n\t/**\n\t * Allows to listen for file changes. The event will fire for every file within the opened workspace\n\t * (if any) as well as all files that have been watched explicitly using the #watch() API.\n\t */\n\treadonly onDidFilesChange: Event<FileChangesEvent>;\n\n\t/**\n\t * An event that is fired upon successful completion of a certain file operation.\n\t */\n\treadonly onDidRunOperation: Event<FileOperationEvent>;\n\n\t/**\n\t * Resolve the properties of a file/folder identified by the resource.\n\t *\n\t * If the optional parameter \"resolveTo\" is specified in options, the stat service is asked\n\t * to provide a stat object that should contain the full graph of folders up to all of the\n\t * target resources.\n\t *\n\t * If the optional parameter \"resolveSingleChildDescendants\" is specified in options,\n\t * the stat service is asked to automatically resolve child folders that only\n\t * contain a single element.\n\t *\n\t * If the optional parameter \"resolveMetadata\" is specified in options,\n\t * the stat will contain metadata information such as size, mtime and etag.\n\t */\n\tresolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\n\t/**\n\t * Same as resolve() but supports resolving multiple resources in parallel.\n\t * If one of the resolve targets fails to resolve returns a fake IFileStat instead of making the whole call fail.\n\t */\n\tresolveAll(toResolve: { resource: URI, options: IResolveMetadataFileOptions }[]): Promise<IResolveFileResult[]>;\n\tresolveAll(toResolve: { resource: URI, options?: IResolveFileOptions }[]): Promise<IResolveFileResult[]>;\n\n\t/**\n\t * Finds out if a file/folder identified by the resource exists.\n\t */\n\texists(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Read the contents of the provided resource unbuffered.\n\t */\n\treadFile(resource: URI, options?: IReadFileOptions): Promise<IFileContent>;\n\n\t/**\n\t * Read the contents of the provided resource buffered as stream.\n\t */\n\treadFileStream(resource: URI, options?: IReadFileOptions): Promise<IFileStreamContent>;\n\n\t/**\n\t * Updates the content replacing its previous value.\n\t */\n\twriteFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Moves the file/folder to a new path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t */\n\tmove(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a move operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Copies the file/folder to a path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t */\n\tcopy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a copy operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Find out if a file create operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;\n\n\t/**\n\t * Creates a new file with the given path and optional contents. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * The optional parameter content can be used as value to fill into the new file.\n\t */\n\tcreateFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Creates a new folder with the given path. The returned promise\n\t * will have the stat model object as a result.\n\t */\n\tcreateFolder(resource: URI): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Deletes the provided file. The optional useTrash parameter allows to\n\t * move the file to trash. The optional recursive parameter allows to delete\n\t * non-empty folders recursively.\n\t */\n\tdel(resource: URI, options?: { useTrash?: boolean, recursive?: boolean }): Promise<void>;\n\n\t/**\n\t * Find out if a delete operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanDelete(resource: URI, options?: { useTrash?: boolean, recursive?: boolean }): Promise<Error | true>;\n\n\t/**\n\t * Allows to start a watcher that reports file/folder change events on the provided resource.\n\t *\n\t * Note: watching a folder does not report events recursively for child folders yet.\n\t */\n\twatch(resource: URI): IDisposable;\n\n\t/**\n\t * Frees up any resources occupied by this service.\n\t */\n\tdispose(): void;\n}\n\nexport interface FileOverwriteOptions {\n\toverwrite: boolean;\n}\n\nexport interface FileReadStreamOptions {\n\n\t/**\n\t * Is an integer specifying where to begin reading from in the file. If position is undefined,\n\t * data will be read from the current file position.\n\t */\n\treadonly position?: number;\n\n\t/**\n\t * Is an integer specifying how many bytes to read from the file. By default, all bytes\n\t * will be read.\n\t */\n\treadonly length?: number;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits.\n\t */\n\tlimits?: {\n\t\treadonly size?: number;\n\t\treadonly memory?: number;\n\t};\n}\n\nexport interface FileWriteOptions {\n\toverwrite: boolean;\n\tcreate: boolean;\n}\n\nexport interface FileOpenOptions {\n\tcreate: boolean;\n}\n\nexport interface FileDeleteOptions {\n\trecursive: boolean;\n\tuseTrash: boolean;\n}\n\nexport enum FileType {\n\tUnknown = 0,\n\tFile = 1,\n\tDirectory = 2,\n\tSymbolicLink = 64\n}\n\nexport interface IStat {\n\ttype: FileType;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t */\n\tmtime: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t */\n\tctime: number;\n\n\tsize: number;\n}\n\nexport interface IWatchOptions {\n\trecursive: boolean;\n\texcludes: string[];\n}\n\nexport const enum FileSystemProviderCapabilities {\n\tFileReadWrite = 1 << 1,\n\tFileOpenReadWriteClose = 1 << 2,\n\tFileReadStream = 1 << 4,\n\n\tFileFolderCopy = 1 << 3,\n\n\tPathCaseSensitive = 1 << 10,\n\tReadonly = 1 << 11,\n\n\tTrash = 1 << 12\n}\n\nexport interface IFileSystemProvider {\n\n\treadonly capabilities: FileSystemProviderCapabilities;\n\treadonly onDidChangeCapabilities: Event<void>;\n\n\treadonly onDidErrorOccur?: Event<string>; // TODO@ben remove once file watchers are solid\n\n\treadonly onDidChangeFile: Event<readonly IFileChange[]>;\n\twatch(resource: URI, opts: IWatchOptions): IDisposable;\n\n\tstat(resource: URI): Promise<IStat>;\n\tmkdir(resource: URI): Promise<void>;\n\treaddir(resource: URI): Promise<[string, FileType][]>;\n\tdelete(resource: URI, opts: FileDeleteOptions): Promise<void>;\n\n\trename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\tcopy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n\treadFile?(resource: URI): Promise<Uint8Array>;\n\twriteFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n\n\treadFileStream?(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n\topen?(resource: URI, opts: FileOpenOptions): Promise<number>;\n\tclose?(fd: number): Promise<void>;\n\tread?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport interface IFileSystemProviderWithFileReadWriteCapability extends IFileSystemProvider {\n\treadFile(resource: URI): Promise<Uint8Array>;\n\twriteFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadWriteCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\nexport interface IFileSystemProviderWithFileFolderCopyCapability extends IFileSystemProvider {\n\tcopy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileFolderCopyCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\nexport interface IFileSystemProviderWithOpenReadWriteCloseCapability extends IFileSystemProvider {\n\topen(resource: URI, opts: FileOpenOptions): Promise<number>;\n\tclose(fd: number): Promise<void>;\n\tread(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithOpenReadWriteCloseCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\nexport interface IFileSystemProviderWithFileReadStreamCapability extends IFileSystemProvider {\n\treadFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadStreamCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport enum FileSystemProviderErrorCode {\n\tFileExists = 'EntryExists',\n\tFileNotFound = 'EntryNotFound',\n\tFileNotADirectory = 'EntryNotADirectory',\n\tFileIsADirectory = 'EntryIsADirectory',\n\tFileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\n\tFileTooLarge = 'EntryTooLarge',\n\tNoPermissions = 'NoPermissions',\n\tUnavailable = 'Unavailable',\n\tUnknown = 'Unknown'\n}\n\nexport class FileSystemProviderError extends Error {\n\n\tconstructor(message: string, public readonly code: FileSystemProviderErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n\tconst providerError = new FileSystemProviderError(error.toString(), code);\n\tmarkAsFileSystemProviderError(providerError, code);\n\n\treturn providerError;\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n\tif (!error) {\n\t\treturn createFileSystemProviderError(localize('unknownError', \"Unknown Error\"), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798\n\t}\n\n\treturn error;\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n\terror.name = code ? `${code} (FileSystemError)` : `FileSystemError`;\n\n\treturn error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n\t// Guard against abuse\n\tif (!error) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\t// FileSystemProviderError comes with the code\n\tif (error instanceof FileSystemProviderError) {\n\t\treturn error.code;\n\t}\n\n\t// Any other error, check for name match by assuming that the error\n\t// went through the markAsFileSystemProviderError() method\n\tconst match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n\tif (!match) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\tswitch (match[1]) {\n\t\tcase FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n\t\tcase FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n\t\tcase FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n\t\tcase FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n\t}\n\n\treturn FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n\t// FileSystemProviderError comes with the result already\n\tif (error instanceof FileOperationError) {\n\t\treturn error.fileOperationResult;\n\t}\n\n\t// Otherwise try to find from code\n\tswitch (toFileSystemProviderErrorCode(error)) {\n\t\tcase FileSystemProviderErrorCode.FileNotFound:\n\t\t\treturn FileOperationResult.FILE_NOT_FOUND;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory:\n\t\t\treturn FileOperationResult.FILE_IS_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory:\n\t\t\treturn FileOperationResult.FILE_NOT_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.NoPermissions:\n\t\t\treturn FileOperationResult.FILE_PERMISSION_DENIED;\n\t\tcase FileSystemProviderErrorCode.FileExists:\n\t\t\treturn FileOperationResult.FILE_MOVE_CONFLICT;\n\t\tcase FileSystemProviderErrorCode.FileExceedsMemoryLimit:\n\t\t\treturn FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge:\n\t\t\treturn FileOperationResult.FILE_TOO_LARGE;\n\t\tdefault:\n\t\t\treturn FileOperationResult.FILE_OTHER_ERROR;\n\t}\n}\n\nexport interface IFileSystemProviderRegistrationEvent {\n\tadded: boolean;\n\tscheme: string;\n\tprovider?: IFileSystemProvider;\n}\n\nexport interface IFileSystemProviderCapabilitiesChangeEvent {\n\tprovider: IFileSystemProvider;\n\tscheme: string;\n}\n\nexport interface IFileSystemProviderActivationEvent {\n\tscheme: string;\n\tjoin(promise: Promise<void>): void;\n}\n\nexport const enum FileOperation {\n\tCREATE,\n\tDELETE,\n\tMOVE,\n\tCOPY\n}\n\nexport class FileOperationEvent {\n\n\tconstructor(resource: URI, operation: FileOperation.DELETE);\n\tconstructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: IFileStatWithMetadata);\n\tconstructor(public readonly resource: URI, public readonly operation: FileOperation, public readonly target?: IFileStatWithMetadata) { }\n\n\tisOperation(operation: FileOperation.DELETE): boolean;\n\tisOperation(operation: FileOperation.MOVE | FileOperation.COPY | FileOperation.CREATE): this is { readonly target: IFileStatWithMetadata };\n\tisOperation(operation: FileOperation): boolean {\n\t\treturn this.operation === operation;\n\t}\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n\tUPDATED = 0,\n\tADDED = 1,\n\tDELETED = 2\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface IFileChange {\n\n\t/**\n\t * The type of change that occurred to the file.\n\t */\n\treadonly type: FileChangeType;\n\n\t/**\n\t * The unified resource identifier of the file that changed.\n\t */\n\treadonly resource: URI;\n}\n\nexport class FileChangesEvent {\n\n\t/**\n\t * @deprecated use the `contains()` or `affects` method to efficiently find\n\t * out if the event relates to a given resource. these methods ensure:\n\t * - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\treadonly changes: readonly IFileChange[];\n\n\tprivate readonly added: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\tprivate readonly updated: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\tprivate readonly deleted: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\n\tconstructor(changes: readonly IFileChange[], private readonly ignorePathCasing: boolean) {\n\t\tthis.changes = changes;\n\n\t\tfor (const change of changes) {\n\t\t\tswitch (change.type) {\n\t\t\t\tcase FileChangeType.ADDED:\n\t\t\t\t\tif (!this.added) {\n\t\t\t\t\t\tthis.added = TernarySearchTree.forUris<IFileChange>(this.ignorePathCasing);\n\t\t\t\t\t}\n\t\t\t\t\tthis.added.set(change.resource, change);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\t\tif (!this.updated) {\n\t\t\t\t\t\tthis.updated = TernarySearchTree.forUris<IFileChange>(this.ignorePathCasing);\n\t\t\t\t\t}\n\t\t\t\t\tthis.updated.set(change.resource, change);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.DELETED:\n\t\t\t\t\tif (!this.deleted) {\n\t\t\t\t\t\tthis.deleted = TernarySearchTree.forUris<IFileChange>(this.ignorePathCasing);\n\t\t\t\t\t}\n\t\t\t\t\tthis.deleted.set(change.resource, change);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find out if the file change events match the provided resource.\n\t *\n\t * Note: when passing `FileChangeType.DELETED`, we consider a match\n\t * also when the parent of the resource got deleted.\n\t */\n\tcontains(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: false }, ...types);\n\t}\n\n\t/**\n\t * Find out if the file change events either match the provided\n\t * resource, or contain a child of this resource.\n\t */\n\taffects(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: true }, ...types);\n\t}\n\n\tprivate doContains(resource: URI, options: { includeChildren: boolean }, ...types: FileChangeType[]): boolean {\n\t\tif (!resource) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasTypesFilter = types.length > 0;\n\n\t\t// Added\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.ADDED)) {\n\t\t\tif (this.added?.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.added?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Updated\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.UPDATED)) {\n\t\t\tif (this.updated?.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.updated?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Deleted\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.DELETED)) {\n\t\t\tif (this.deleted?.findSubstr(resource) /* deleted also considers parent folders */) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.deleted?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @deprecated use the `contains()` method to efficiently find out if the event\n\t * relates to a given resource. this method ensures:\n\t * - that there is no expensive lookup needed by using a `TernarySearchTree`\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\tgetAdded(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.ADDED);\n\t}\n\n\t/**\n\t * Returns if this event contains added files.\n\t */\n\tgotAdded(): boolean {\n\t\treturn !!this.added;\n\t}\n\n\t/**\n\t * @deprecated use the `contains()` method to efficiently find out if the event\n\t * relates to a given resource. this method ensures:\n\t * - that there is no expensive lookup needed by using a `TernarySearchTree`\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\tgetDeleted(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.DELETED);\n\t}\n\n\t/**\n\t * Returns if this event contains deleted files.\n\t */\n\tgotDeleted(): boolean {\n\t\treturn !!this.deleted;\n\t}\n\n\t/**\n\t * @deprecated use the `contains()` method to efficiently find out if the event\n\t * relates to a given resource. this method ensures:\n\t * - that there is no expensive lookup needed by using a `TernarySearchTree`\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\tgetUpdated(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.UPDATED);\n\t}\n\n\t/**\n\t * Returns if this event contains updated files.\n\t */\n\tgotUpdated(): boolean {\n\t\treturn !!this.updated;\n\t}\n\n\tprivate getOfType(type: FileChangeType): IFileChange[] {\n\t\tconst changes: IFileChange[] = [];\n\n\t\tconst eventsForType = type === FileChangeType.ADDED ? this.added : type === FileChangeType.UPDATED ? this.updated : this.deleted;\n\t\tif (eventsForType) {\n\t\t\tfor (const [, change] of eventsForType) {\n\t\t\t\tchanges.push(change);\n\t\t\t}\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * @deprecated use the `contains()` method to efficiently find out if the event\n\t * relates to a given resource. this method ensures:\n\t * - that there is no expensive lookup needed by using a `TernarySearchTree`\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\tfilter(filterFn: (change: IFileChange) => boolean): FileChangesEvent {\n\t\treturn new FileChangesEvent(this.changes.filter(change => filterFn(change)), this.ignorePathCasing);\n\t}\n}\n\nexport function isParent(path: string, candidate: string, ignoreCase?: boolean): boolean {\n\tif (!path || !candidate || path === candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== sep) {\n\t\tcandidate += sep;\n\t}\n\n\tif (ignoreCase) {\n\t\treturn startsWithIgnoreCase(path, candidate);\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\ninterface IBaseStat {\n\n\t/**\n\t * The unified resource identifier of this file or folder.\n\t */\n\tresource: URI;\n\n\t/**\n\t * The name which is the last segment\n\t * of the {{path}}.\n\t */\n\tname: string;\n\n\t/**\n\t * The size of the file.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\tsize?: number;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\tmtime?: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\tctime?: number;\n\n\t/**\n\t * A unique identifier thet represents the\n\t * current state of the file or directory.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\tetag?: string;\n}\n\nexport interface IBaseStatWithMetadata extends IBaseStat {\n\tmtime: number;\n\tctime: number;\n\tetag: string;\n\tsize: number;\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface IFileStat extends IBaseStat {\n\n\t/**\n\t * The resource is a file.\n\t */\n\tisFile: boolean;\n\n\t/**\n\t * The resource is a directory.\n\t */\n\tisDirectory: boolean;\n\n\t/**\n\t * The resource is a symbolic link.\n\t */\n\tisSymbolicLink: boolean;\n\n\t/**\n\t * The children of the file stat or undefined if none.\n\t */\n\tchildren?: IFileStat[];\n}\n\nexport interface IFileStatWithMetadata extends IFileStat, IBaseStatWithMetadata {\n\tmtime: number;\n\tctime: number;\n\tetag: string;\n\tsize: number;\n\tchildren?: IFileStatWithMetadata[];\n}\n\nexport interface IResolveFileResult {\n\tstat?: IFileStat;\n\tsuccess: boolean;\n}\n\nexport interface IResolveFileResultWithMetadata extends IResolveFileResult {\n\tstat?: IFileStatWithMetadata;\n}\n\nexport interface IFileContent extends IBaseStatWithMetadata {\n\n\t/**\n\t * The content of a file as buffer.\n\t */\n\tvalue: VSBuffer;\n}\n\nexport interface IFileStreamContent extends IBaseStatWithMetadata {\n\n\t/**\n\t * The content of a file as stream.\n\t */\n\tvalue: VSBufferReadableStream;\n}\n\nexport interface IReadFileOptions extends FileReadStreamOptions {\n\n\t/**\n\t * The optional etag parameter allows to return early from resolving the resource if\n\t * the contents on disk match the etag. This prevents accumulated reading of resources\n\t * that have been read already with the same etag.\n\t * It is the task of the caller to makes sure to handle this error case from the promise.\n\t */\n\treadonly etag?: string;\n}\n\nexport interface IWriteFileOptions {\n\n\t/**\n\t * The last known modification time of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly mtime?: number;\n\n\t/**\n\t * The etag of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly etag?: string;\n}\n\nexport interface IResolveFileOptions {\n\n\t/**\n\t * Automatically continue resolving children of a directory until the provided resources\n\t * are found.\n\t */\n\treadonly resolveTo?: readonly URI[];\n\n\t/**\n\t * Automatically continue resolving children of a directory if the number of children is 1.\n\t */\n\treadonly resolveSingleChildDescendants?: boolean;\n\n\t/**\n\t * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n\t * on performance and thus should only be used when these values are required.\n\t */\n\treadonly resolveMetadata?: boolean;\n}\n\nexport interface IResolveMetadataFileOptions extends IResolveFileOptions {\n\treadonly resolveMetadata: true;\n}\n\nexport interface ICreateFileOptions {\n\n\t/**\n\t * Overwrite the file to create if it already exists on disk. Otherwise\n\t * an error will be thrown (FILE_MODIFIED_SINCE).\n\t */\n\treadonly overwrite?: boolean;\n}\n\nexport class FileOperationError extends Error {\n\tconstructor(message: string, public fileOperationResult: FileOperationResult, public options?: IReadFileOptions & IWriteFileOptions & ICreateFileOptions) {\n\t\tsuper(message);\n\t}\n\n\tstatic isFileOperationError(obj: unknown): obj is FileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as FileOperationError).fileOperationResult);\n\t}\n}\n\nexport const enum FileOperationResult {\n\tFILE_IS_DIRECTORY,\n\tFILE_NOT_FOUND,\n\tFILE_NOT_MODIFIED_SINCE,\n\tFILE_MODIFIED_SINCE,\n\tFILE_MOVE_CONFLICT,\n\tFILE_READ_ONLY,\n\tFILE_PERMISSION_DENIED,\n\tFILE_TOO_LARGE,\n\tFILE_INVALID_PATH,\n\tFILE_EXCEEDS_MEMORY_LIMIT,\n\tFILE_NOT_DIRECTORY,\n\tFILE_OTHER_ERROR\n}\n\nexport const AutoSaveConfiguration = {\n\tOFF: 'off',\n\tAFTER_DELAY: 'afterDelay',\n\tON_FOCUS_CHANGE: 'onFocusChange',\n\tON_WINDOW_CHANGE: 'onWindowChange'\n};\n\nexport const HotExitConfiguration = {\n\tOFF: 'off',\n\tON_EXIT: 'onExit',\n\tON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'\n};\n\nexport const FILES_ASSOCIATIONS_CONFIG = 'files.associations';\nexport const FILES_EXCLUDE_CONFIG = 'files.exclude';\n\nexport interface IFilesConfiguration {\n\tfiles: {\n\t\tassociations: { [filepattern: string]: string };\n\t\texclude: glob.IExpression;\n\t\twatcherExclude: { [filepattern: string]: boolean };\n\t\tencoding: string;\n\t\tautoGuessEncoding: boolean;\n\t\tdefaultLanguage: string;\n\t\ttrimTrailingWhitespace: boolean;\n\t\tautoSave: string;\n\t\tautoSaveDelay: number;\n\t\teol: string;\n\t\tenableTrash: boolean;\n\t\thotExit: string;\n\t\tsaveConflictResolution: 'askUser' | 'overwriteFileOnDisk';\n\t};\n}\n\nexport enum FileKind {\n\tFILE,\n\tFOLDER,\n\tROOT_FOLDER\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number, size: number }): string;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined {\n\tif (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n\t\treturn undefined;\n\t}\n\n\treturn stat.mtime.toString(29) + stat.size.toString(31);\n}\n\nexport function whenProviderRegistered(file: URI, fileService: IFileService): Promise<void> {\n\tif (fileService.canHandleResource(URI.from({ scheme: file.scheme }))) {\n\t\treturn Promise.resolve();\n\t}\n\n\treturn new Promise(resolve => {\n\t\tconst disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\tif (e.scheme === file.scheme && e.added) {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Native only: limits for memory sizes\n */\nexport const MIN_MAX_MEMORY_SIZE_MB = 2048;\nexport const FALLBACK_MAX_MEMORY_SIZE_MB = 4096;\n\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class BinarySize {\n\tstatic readonly KB = 1024;\n\tstatic readonly MB = BinarySize.KB * BinarySize.KB;\n\tstatic readonly GB = BinarySize.MB * BinarySize.KB;\n\tstatic readonly TB = BinarySize.GB * BinarySize.KB;\n\n\tstatic formatSize(size: number): string {\n\t\tif (!isNumber(size)) {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tif (size < BinarySize.KB) {\n\t\t\treturn localize('sizeB', \"{0}B\", size.toFixed(0));\n\t\t}\n\n\t\tif (size < BinarySize.MB) {\n\t\t\treturn localize('sizeKB', \"{0}KB\", (size / BinarySize.KB).toFixed(2));\n\t\t}\n\n\t\tif (size < BinarySize.GB) {\n\t\t\treturn localize('sizeMB', \"{0}MB\", (size / BinarySize.MB).toFixed(2));\n\t\t}\n\n\t\tif (size < BinarySize.TB) {\n\t\t\treturn localize('sizeGB', \"{0}GB\", (size / BinarySize.GB).toFixed(2));\n\t\t}\n\n\t\treturn localize('sizeTB', \"{0}TB\", (size / BinarySize.TB).toFixed(2));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, isParent, IFileChange } from 'vs/platform/files/common/files';\nimport { isLinux } from 'vs/base/common/platform';\n\nexport interface IDiskFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport interface ILogMessage {\n\ttype: 'trace' | 'warn' | 'error';\n\tmessage: string;\n}\n\nexport function toFileChanges(changes: IDiskFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: uri.file(change.path)\n\t}));\n}\n\nexport function normalizeFileChanges(changes: IDiskFileChange[]): IDiskFileChange[] {\n\n\t// Build deltas\n\tconst normalizer = new EventNormalizer();\n\tfor (const event of changes) {\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IDiskFileChange[] = [];\n\tprivate mapPathToChange: Map<string, IDiskFileChange> = new Map();\n\n\tprocessEvent(event: IDiskFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(event.path);\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(event.path);\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise store new\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange.set(event.path, event);\n\t\t}\n\t}\n\n\tnormalize(): IDiskFileChange[] {\n\t\tconst addedChangeEvents: IDiskFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddedChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => isParent(e.path, d, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as chokidar from 'chokidar';\nimport * as fs from 'fs';\nimport * as gracefulFs from 'graceful-fs';\ngracefulFs.gracefulify(fs);\nimport * as extpath from 'vs/base/common/extpath';\nimport * as glob from 'vs/base/common/glob';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { realcaseSync } from 'vs/base/node/extpath';\nimport { isMacintosh, isLinux } from 'vs/base/common/platform';\nimport { IDiskFileChange, normalizeFileChanges, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { IWatcherRequest, IWatcherService, IWatcherOptions } from 'vs/platform/files/node/watcher/unix/watcher';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { equals } from 'vs/base/common/arrays';\nimport { Disposable } from 'vs/base/common/lifecycle';\n\nprocess.noAsar = true; // disable ASAR support in watcher process\n\ninterface IWatcher {\n\trequests: ExtendedWatcherRequest[];\n\tstop(): Promise<void>;\n}\n\ninterface ExtendedWatcherRequest extends IWatcherRequest {\n\tparsedPattern?: glob.ParsedPattern;\n}\n\nexport class ChokidarWatcherService extends Disposable implements IWatcherService {\n\n\tprivate static readonly FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n\tprivate static readonly EVENT_SPAM_WARNING_THRESHOLD = 60 * 1000; // warn after certain time span of event spam\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<IDiskFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprivate readonly _onDidLogMessage = this._register(new Emitter<ILogMessage>());\n\treadonly onDidLogMessage: Event<ILogMessage> = this._onDidLogMessage.event;\n\n\tprivate watchers = new Map<string, IWatcher>();\n\n\tprivate _watcherCount = 0;\n\tget wacherCount() { return this._watcherCount; }\n\n\tprivate pollingInterval?: number;\n\tprivate usePolling?: boolean;\n\tprivate verboseLogging: boolean | undefined;\n\n\tprivate spamCheckStartTime: number | undefined;\n\tprivate spamWarningLogged: boolean | undefined;\n\tprivate enospcErrorLogged: boolean | undefined;\n\n\tasync init(options: IWatcherOptions): Promise<void> {\n\t\tthis.pollingInterval = options.pollingInterval;\n\t\tthis.usePolling = options.usePolling;\n\t\tthis.watchers.clear();\n\t\tthis._watcherCount = 0;\n\t\tthis.verboseLogging = options.verboseLogging;\n\t}\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\t}\n\n\tasync setRoots(requests: IWatcherRequest[]): Promise<void> {\n\t\tconst watchers = new Map<string, IWatcher>();\n\t\tconst newRequests: string[] = [];\n\n\t\tconst requestsByBasePath = normalizeRoots(requests);\n\n\t\t// evaluate new & remaining watchers\n\t\tfor (const basePath in requestsByBasePath) {\n\t\t\tconst watcher = this.watchers.get(basePath);\n\t\t\tif (watcher && isEqualRequests(watcher.requests, requestsByBasePath[basePath])) {\n\t\t\t\twatchers.set(basePath, watcher);\n\t\t\t\tthis.watchers.delete(basePath);\n\t\t\t} else {\n\t\t\t\tnewRequests.push(basePath);\n\t\t\t}\n\t\t}\n\n\t\t// stop all old watchers\n\t\tfor (const [, watcher] of this.watchers) {\n\t\t\tawait watcher.stop();\n\t\t}\n\n\t\t// start all new watchers\n\t\tfor (const basePath of newRequests) {\n\t\t\tconst requests = requestsByBasePath[basePath];\n\t\t\twatchers.set(basePath, this.watch(basePath, requests));\n\t\t}\n\n\t\tthis.watchers = watchers;\n\t}\n\n\tprivate watch(basePath: string, requests: IWatcherRequest[]): IWatcher {\n\t\tconst pollingInterval = this.pollingInterval || 5000;\n\t\tconst usePolling = this.usePolling;\n\n\t\tconst watcherOpts: chokidar.WatchOptions = {\n\t\t\tignoreInitial: true,\n\t\t\tignorePermissionErrors: true,\n\t\t\tfollowSymlinks: true, // this is the default of chokidar and supports file events through symlinks\n\t\t\tinterval: pollingInterval, // while not used in normal cases, if any error causes chokidar to fallback to polling, increase its intervals\n\t\t\tbinaryInterval: pollingInterval,\n\t\t\tusePolling: usePolling,\n\t\t\tdisableGlobbing: true // fix https://github.com/microsoft/vscode/issues/4586\n\t\t};\n\n\t\tconst excludes: string[] = [];\n\n\t\tconst isSingleFolder = requests.length === 1;\n\t\tif (isSingleFolder) {\n\t\t\texcludes.push(...requests[0].excludes); // if there's only one request, use the built-in ignore-filterering\n\t\t}\n\n\t\tif ((isMacintosh || isLinux) && (basePath.length === 0 || basePath === '/')) {\n\t\t\texcludes.push('/dev/**');\n\t\t\tif (isLinux) {\n\t\t\t\texcludes.push('/proc/**', '/sys/**');\n\t\t\t}\n\t\t}\n\n\t\texcludes.push('**/*.asar'); // Ensure we never recurse into ASAR archives\n\n\t\twatcherOpts.ignored = excludes;\n\n\t\t// Chokidar fails when the basePath does not match case-identical to the path on disk\n\t\t// so we have to find the real casing of the path and do some path massaging to fix this\n\t\t// see https://github.com/paulmillr/chokidar/issues/418\n\t\tconst realBasePath = isMacintosh ? (realcaseSync(basePath) || basePath) : basePath;\n\t\tconst realBasePathLength = realBasePath.length;\n\t\tconst realBasePathDiffers = (basePath !== realBasePath);\n\n\t\tif (realBasePathDiffers) {\n\t\t\tthis.warn(`Watcher basePath does not match version on disk and was corrected (original: ${basePath}, real: ${realBasePath})`);\n\t\t}\n\n\t\tif (this.verboseLogging) {\n\t\t\tthis.log(`Start watching with chockidar: ${realBasePath}, excludes: ${excludes.join(',')}, usePolling: ${usePolling ? 'true, interval ' + pollingInterval : 'false'}`);\n\t\t}\n\n\t\tlet chokidarWatcher: chokidar.FSWatcher | null = chokidar.watch(realBasePath, watcherOpts);\n\t\tthis._watcherCount++;\n\n\t\t// Detect if for some reason the native watcher library fails to load\n\t\tif (isMacintosh && chokidarWatcher.options && !chokidarWatcher.options.useFsEvents) {\n\t\t\tthis.warn('Watcher is not using native fsevents library and is falling back to unefficient polling.');\n\t\t}\n\n\t\tlet undeliveredFileEvents: IDiskFileChange[] = [];\n\t\tlet fileEventDelayer: ThrottledDelayer<undefined> | null = new ThrottledDelayer(ChokidarWatcherService.FS_EVENT_DELAY);\n\n\t\tconst watcher: IWatcher = {\n\t\t\trequests,\n\t\t\tstop: async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\t\tthis.log(`Stop watching: ${basePath}]`);\n\t\t\t\t\t}\n\t\t\t\t\tif (chokidarWatcher) {\n\t\t\t\t\t\tawait chokidarWatcher.close();\n\t\t\t\t\t\tthis._watcherCount--;\n\t\t\t\t\t\tchokidarWatcher = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (fileEventDelayer) {\n\t\t\t\t\t\tfileEventDelayer.cancel();\n\t\t\t\t\t\tfileEventDelayer = null;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.warn('Error while stopping watcher: ' + error.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tchokidarWatcher.on('all', (type: string, path: string) => {\n\t\t\tif (isMacintosh) {\n\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\tpath = normalizeNFC(path);\n\t\t\t}\n\n\t\t\tif (path.indexOf(realBasePath) < 0) {\n\t\t\t\treturn; // we really only care about absolute paths here in our basepath context here\n\t\t\t}\n\n\t\t\t// Make sure to convert the path back to its original basePath form if the realpath is different\n\t\t\tif (realBasePathDiffers) {\n\t\t\t\tpath = basePath + path.substr(realBasePathLength);\n\t\t\t}\n\n\t\t\tlet eventType: FileChangeType;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'change':\n\t\t\t\t\teventType = FileChangeType.UPDATED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'add':\n\t\t\t\tcase 'addDir':\n\t\t\t\t\teventType = FileChangeType.ADDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unlink':\n\t\t\t\tcase 'unlinkDir':\n\t\t\t\t\teventType = FileChangeType.DELETED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if there's more than one request we need to do\n\t\t\t// extra filtering due to potentially overlapping roots\n\t\t\tif (!isSingleFolder) {\n\t\t\t\tif (isIgnored(path, watcher.requests)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst event = { type: eventType, path };\n\n\t\t\t// Logging\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.log(`${eventType === FileChangeType.ADDED ? '[ADDED]' : eventType === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`);\n\t\t\t}\n\n\t\t\t// Check for spam\n\t\t\tconst now = Date.now();\n\t\t\tif (undeliveredFileEvents.length === 0) {\n\t\t\t\tthis.spamWarningLogged = false;\n\t\t\t\tthis.spamCheckStartTime = now;\n\t\t\t} else if (!this.spamWarningLogged && typeof this.spamCheckStartTime === 'number' && this.spamCheckStartTime + ChokidarWatcherService.EVENT_SPAM_WARNING_THRESHOLD < now) {\n\t\t\t\tthis.spamWarningLogged = true;\n\t\t\t\tthis.warn(`Watcher is busy catching up with ${undeliveredFileEvents.length} file changes in 60 seconds. Latest changed path is \"${event.path}\"`);\n\t\t\t}\n\n\t\t\t// Add to buffer\n\t\t\tundeliveredFileEvents.push(event);\n\n\t\t\tif (fileEventDelayer) {\n\n\t\t\t\t// Delay and send buffer\n\t\t\t\tfileEventDelayer.trigger(async () => {\n\t\t\t\t\tconst events = undeliveredFileEvents;\n\t\t\t\t\tundeliveredFileEvents = [];\n\n\t\t\t\t\t// Broadcast to clients normalized\n\t\t\t\t\tconst res = normalizeFileChanges(events);\n\t\t\t\t\tthis._onDidChangeFile.fire(res);\n\n\t\t\t\t\t// Logging\n\t\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\t\tres.forEach(r => {\n\t\t\t\t\t\t\tthis.log(` >> normalized  ${r.type === FileChangeType.ADDED ? '[ADDED]' : r.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tchokidarWatcher.on('error', (error: NodeJS.ErrnoException) => {\n\t\t\tif (error) {\n\n\t\t\t\t// Specially handle ENOSPC errors that can happen when\n\t\t\t\t// the watcher consumes so many file descriptors that\n\t\t\t\t// we are running into a limit. We only want to warn\n\t\t\t\t// once in this case to avoid log spam.\n\t\t\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\t\t\tif (error.code === 'ENOSPC') {\n\t\t\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\tthis.error('Inotify limit reached (ENOSPC)');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.warn(error.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn watcher;\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tfor (const [, watcher] of this.watchers) {\n\t\t\tawait watcher.stop();\n\t\t}\n\n\t\tthis.watchers.clear();\n\t}\n\n\tprivate log(message: string) {\n\t\tthis._onDidLogMessage.fire({ type: 'trace', message: `[File Watcher (chokidar)] ` + message });\n\t}\n\n\tprivate warn(message: string) {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: `[File Watcher (chokidar)] ` + message });\n\t}\n\n\tprivate error(message: string) {\n\t\tthis._onDidLogMessage.fire({ type: 'error', message: `[File Watcher (chokidar)] ` + message });\n\t}\n}\n\nfunction isIgnored(path: string, requests: ExtendedWatcherRequest[]): boolean {\n\tfor (const request of requests) {\n\t\tif (request.path === path) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (extpath.isEqualOrParent(path, request.path)) {\n\t\t\tif (!request.parsedPattern) {\n\t\t\t\tif (request.excludes && request.excludes.length > 0) {\n\t\t\t\t\tconst pattern = `{${request.excludes.join(',')}}`;\n\t\t\t\t\trequest.parsedPattern = glob.parse(pattern);\n\t\t\t\t} else {\n\t\t\t\t\trequest.parsedPattern = () => false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst relPath = path.substr(request.path.length + 1);\n\t\t\tif (!request.parsedPattern(relPath)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Normalizes a set of root paths by grouping by the most parent root path.\n * equests with Sub paths are skipped if they have the same ignored set as the parent.\n */\nexport function normalizeRoots(requests: IWatcherRequest[]): { [basePath: string]: IWatcherRequest[] } {\n\trequests = requests.sort((r1, r2) => r1.path.localeCompare(r2.path));\n\n\tlet prevRequest: IWatcherRequest | null = null;\n\tconst result: { [basePath: string]: IWatcherRequest[] } = Object.create(null);\n\tfor (const request of requests) {\n\t\tconst basePath = request.path;\n\t\tconst ignored = (request.excludes || []).sort();\n\t\tif (prevRequest && (extpath.isEqualOrParent(basePath, prevRequest.path))) {\n\t\t\tif (!isEqualIgnore(ignored, prevRequest.excludes)) {\n\t\t\t\tresult[prevRequest.path].push({ path: basePath, excludes: ignored });\n\t\t\t}\n\t\t} else {\n\t\t\tprevRequest = { path: basePath, excludes: ignored };\n\t\t\tresult[basePath] = [prevRequest];\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction isEqualRequests(r1: readonly IWatcherRequest[], r2: readonly IWatcherRequest[]) {\n\treturn equals(r1, r2, (a, b) => a.path === b.path && isEqualIgnore(a.excludes, b.excludes));\n}\n\nfunction isEqualIgnore(i1: readonly string[], i2: readonly string[]) {\n\treturn equals(i1, i2);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Server } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { ChokidarWatcherService } from 'vs/platform/files/node/watcher/unix/chokidarWatcherService';\nimport { createChannelReceiver } from 'vs/base/parts/ipc/common/ipc';\n\nconst server = new Server('watcher');\nconst service = new ChokidarWatcherService();\nserver.registerChannel('watcher', createChannelReceiver(service));\n"]}